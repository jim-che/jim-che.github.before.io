<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>STL(vector)</title>
    <link href="/2021/03/05/STL-vector/"/>
    <url>/2021/03/05/STL-vector/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>接口与多态(Set)</title>
    <link href="/2021/03/05/%E6%8E%A5%E5%8F%A3%E4%B8%8E%E5%A4%9A%E6%80%81-Set/"/>
    <url>/2021/03/05/%E6%8E%A5%E5%8F%A3%E4%B8%8E%E5%A4%9A%E6%80%81-Set/</url>
    
    <content type="html"><![CDATA[<h2 id="接口与多态-Set"><a href="#接口与多态-Set" class="headerlink" title="接口与多态(Set)"></a>接口与多态(Set)</h2><span id="more"></span><h3 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h3><p>通过哈希码对集合数组进行内部排序，和添加的顺序无关(如果是普通数会根据hash码内部排序)。下面介绍一下基本使用方法。</p><pre><code>    public static void main(String[] args) &#123;        HashSet&lt;String&gt; hash = new HashSet&lt;&gt;();        hash.add(&quot;一&quot;);        hash.add(&quot;二&quot;);        hash.add(&quot;三&quot;);        System.out.println(hash); // [一, 三, 二]        System.out.println(hash.contains(&quot;三&quot;)); // 是否包含 &quot;三&quot; // true        hash.remove(&quot;三&quot;);        System.out.println(hash); // [一, 二]        System.out.println(hash.size());// set的容量 // 2    &#125;</code></pre><p><code>HashSet</code> 本质上是一个 <code>HashMap</code>, 对集合的迭代次序没有任何保证; 特别是，它不能保证订单会随着时间的推移保持不变。这个类允许 <code>null</code> 元素。虽然 <code>HashSet</code> 在很少量 <code>Integer</code> 数据会自动通过哈希码排序，但是对于一般的数据完全不能保证数据的顺序。</p><p>放入 <code>HashSet</code> 的类必须实现 <code>HashCode</code> 方法，这也是 <code>HashSet</code> 进行存放数据的基础。</p><p><code>HashSet</code> 默认创建一个大小为 16 的容器，加载因子是 0.75 ，意思是到 12 个元素，它会自动扩容，扩容成的大小都是 2 的幂， 这些都可以在构造函数时候进行改变。</p><p><code>HashSet</code> 实现了 <code>Cloneable</code> 和 <code>Serializable</code> 说明是可以克隆和序列化的。</p><p><code>HashSet</code> 线程并不安全，和 <code>HashMap</code> 一样。<code>java.util.concurrent</code> 包下的 <code>ConcurrentHashMap</code> 类是线程安全的。</p><h3 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h3><p> <code>TreeSet</code> 是有序的 <code>set</code> 集合，放入 <code>TreeSet</code> 中的数据会自动内部排序，不同于 <code>HashSet</code> 基于哈希表的结构，<code>TreeSet</code> 是基于二叉树的，这也使得 <code>TreeSet</code> 并不支持放入 <code>null</code> 值。</p><p>由于 <code>TreeSet</code> 是可以放入类结构，这就意味着如果我们要将自己的类通过 <code>TreeSet</code> 存储，那么这个类必须实现 <code>Comparable</code> 接口。</p><p><code>TreeSet</code> 和 <code>HashSet</code> 一样，实现了 <code>Cloneable</code> 接口与 <code>Serializable</code> 接口，保证了可被复制，也可以序列化的特性。</p><p><code>TreeSet</code> 是基于 <code>TreeMap</code> 实现的，使用的是 <code>NavigableMap</code> 来进行数据的存放，使用方法和 <code>HashSet</code> 差不多，但是内部结构是截然不同的，它们适用的领域也是不相同的</p><p>下面简单写一下 <code>TreeSet</code> 的部分方法，更多具体方法可以查找JDK文档。</p><pre><code>    public static void main(String[] args) &#123;        TreeSet&lt;Integer&gt; treeSet = new TreeSet&lt;&gt;();        treeSet.add(1);        treeSet.add(3);        treeSet.add(2);        System.out.println(treeSet);// [1, 2, 3]        treeSet.remove(3);        System.out.println(treeSet);// [1, 2]        System.out.println(treeSet.contains(3));// false    &#125;</code></pre><p>需要注意的是 <code>TreeSet</code> 同样是 <code>fail-fast</code> 的，是线程不安全的。</p><h3 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a>LinkedHashSet</h3><p>看名字就知道，也是一个的哈希结构，本身也是继承 <code>HashSet</code> 而来的，也实现了和 <code>HashSet</code> 一样的 <code>Serializable</code> 和 <code>Cloneable</code> 接口。默认也为加载因素为0.75，大小为16的容器。</p><p><code>LinkedHashSet</code> 是一个基于哈希表和双向链表的接口，增加删除等方法都是基于链表结构的，所以它的存储结构在逻辑上是有序的，迭代时获取元素的顺序等于元素的添加顺序，注意这里不是访问顺序。</p><p> <code>LinkedHashSet</code> 在添加了一个全局的双向链表的结构，所以相比较于 <code>HashSet</code> 而言，查找慢，添加元素稍慢，但迭代访问快，性能更强。也是基于哈希函数查看容器中是否存在，如果不存在才会添加。</p><p>使用方法基本无异，唯一区别就是迭代获取元素的顺序是和添加的顺序一致，这里就不在赘述代码了。</p><p>同样的，<code>LinkedHashSet</code> 也是 <code>fail-fast</code> 线程不安全的。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>三种结构各有各的优势，虽然在方法上大相近同，但在底层区别还是不晓得，在实际使用中要通过对源码的分析来确定使用哪个类，才能获得更高的性能。</p><p>三种结构虽然都是线程不安全的，但是原理也都是线程安全类的基础，需要牢牢掌握。</p>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
      <category>Java</category>
      
      <category>Java基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编程语言的运用</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>接口与多态(List)</title>
    <link href="/2021/03/04/%E6%8E%A5%E5%8F%A3%E4%B8%8E%E5%A4%9A%E6%80%81-List/"/>
    <url>/2021/03/04/%E6%8E%A5%E5%8F%A3%E4%B8%8E%E5%A4%9A%E6%80%81-List/</url>
    
    <content type="html"><![CDATA[<h2 id="接口与多态-List"><a href="#接口与多态-List" class="headerlink" title="接口与多态(List)"></a>接口与多态(List)</h2><span id="more"></span><h3 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p> <code>ArrayList</code> 是基于数组实现的，是一个动态数组，其容量能自动增长。</p><p> <code>ArrayList</code> 不是线程安全的，只能用在单线程环境下，多线程环境下可以考虑用 <code>Collections.synchronizedList(List l)</code> 函数返回一个线程安全的 <code>ArrayList</code> 类，也可以使用 <code>concurrent</code> 并发包下的 <code>CopyOnWriteArrayList</code> 类。 </p><p> <code>ArrayList</code> 实现了 <code>Serializable</code> 接口，因此它支持序列化，能够通过序列化传输，实现了 <code>RandomAccess</code> 接口，支持快速随机访问，实际上就是通过下标序号进行快速访问，实现了 <code>Cloneable</code> 接口，能被克隆。</p><p>每个 <code>ArrayList</code> 实例都有一个容量，该容量是指用来存储列表元素的数组的大小。它总是至少等于列表的大小。随着向 <code>ArrayList</code> 中不断添加元素，其容量也自动增长。自动增长会带来数据向新数组的重新拷贝，因此，如果可预知数据量的多少，可在构造 <code>ArrayList</code> 时指定其容量。在添加大量元素前，应用程序也可以使用 <code>ensureCapacity</code> 操作来增加ArrayList实例的容量，这可以减少递增式再分配的数量。</p><p>注意，此实现不是同步的。如果多个线程同时访问一个 <code>ArrayList</code> 实例，而其中至少一个线程从结构上修改了列表，那么它必须保持外部同步。</p><h4 id="ArrayList的实现："><a href="#ArrayList的实现：" class="headerlink" title="ArrayList的实现："></a>ArrayList的实现：</h4><p>对于ArrayList而言，它实现List接口、底层使用数组保存所有元素。其操作基本上是对数组的操作。下面我们来分析ArrayList的源代码：</p><pre><code>  ArrayList定义只定义类两个私有属性：   /**       * The array buffer into which the elements of the ArrayList are stored.       * The capacity of the ArrayList is the length of this array buffer.       */       private transient Object[] elementData;        /**       * The size of the ArrayList (the number of elements it contains).       *       * @serial       */       private int size;</code></pre><p> <code>elementData</code> 储存 <code>ArrayList</code> 内的元素，<code>size</code> 表示长度。</p><p>有个关键字需要解释： <code>transient</code> 。</p><p>Java的 <code>serialization</code> 提供了一种持久化对象实例的机制。当持久化对象时，可能有一个特殊的对象数据成员，我们不想用 <code>serialization</code> 机制来保存它。为了在一个特定对象的一个域上关闭 <code>serialization</code> ，可以在这个域前加上关键字 <code>transient</code>。</p><h4 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法:"></a>基本用法:</h4><p>上一段代码</p><pre><code>public static void main(String[] args) &#123;    ArrayList list = new ArrayList();    String[] Array = &quot;Hello World Java&quot;.split(&quot; &quot;);    list.add(Array[0]);    list.add(Array[1]);    list.add(Array[2]);    list.add(5);    System.out.println(list.get(1).getClass());    System.out.println((int)list.get(3) + 2);&#125;</code></pre><p>结果</p><pre><code>World7</code></pre><p><code>ArrayList</code> 也是可以添加相同的元素的。</p><p>下面我们看一下 <code>ArrayList</code> 最基本的增删改查</p><pre><code>public static void main(String[] args) &#123;    ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;();    list.add(4);    list.add(3);    list.add(1);    System.out.println(list);// [4, 3, 1]    list.add(2, 2);// 在2处插入2    System.out.println(list);// [4, 3, 2, 1]    list.sort(new Comparator&lt;Integer&gt;() &#123;        @Override        public int compare(Integer o1, Integer o2) &#123;            return o1-o2;        &#125;    &#125;);// 排序    System.out.println(list);// [1, 2, 3, 4]    list.remove(0);// 删除0处的元素    System.out.println(list);// [2, 3, 4]    list.set(0, 8);// 将0处的元素改为8    System.out.println(list);// [8, 3, 4]&#125;</code></pre><p><a href="https://www.runoob.com/java/java-arraylist.html">更多方法</a></p><p>我们看一下 <code>ArrayList</code> 中的遍历。</p><p>第一种：通过迭代器遍历，即通过Iterator去遍历</p><pre><code>Integer value = null;Iterator iter = list.iterator();while (iter.hasNext()) &#123;    value = (Integer)iter.next();&#125;</code></pre><p>第二种：随机访问，通过索引值去遍历，因为ArrayList实现了RandomAccess接口，so，她支持通过索引值去随机访问元素：</p><pre><code>Integer value = null;int size = list.size();for (int i=0; i&lt;size; i++) &#123;    value = (Integer)list.get(i);        &#125;</code></pre><p>第三种：for循环遍历，如下所示：</p><pre><code>Integer value = null;for (Integer integ:list) &#123;    value = integ;&#125;</code></pre><p>如果实际测试下来我们可以发现，遍历ArrayList时，使用随机访问(即，通过索引序号访问)效率最高，而使用迭代器的效率最低！</p><h4 id="ArrayList的优缺点"><a href="#ArrayList的优缺点" class="headerlink" title="ArrayList的优缺点"></a>ArrayList的优缺点</h4><p><strong>优点</strong>:</p><ol><li><p> <code>ArrayList</code> 底层以数组实现，是一种随机访问模式，再加上它实现了 <code>RandomAccess</code> 接口，因此查找速度快；</p></li><li><p> <code>ArrayList</code> 在顺序添加一个元素的时候非常方便，只是往数组里面添加了一个元素而已；</p></li></ol><p><strong>缺点</strong>:</p><ol><li><p>删除元素的时候，涉及到一次元素复制，如果要复制的元素很多，那么就会比较耗费性能</p></li><li><p>插入元素的时候，涉及到一次元素复制，如果要复制的元素很多，那么就会比较耗费性能</p></li></ol><p><strong>ArrayList线程问题</strong>:</p><p><code>ArrayList</code> 是线程不安全的，这个由它的实现方式决定。</p><p>我们知道ArrayList在添加一个元素的时候，需要两个步骤，第一步在Items[Size]的位置存放此元素，第二步增大Size的值，在单线程运行的情况，比如两个苹果两个人吃，一个人吃一个，这个是并发的，互不影响，但是如果一个人吃两个苹果，要保证同时吃完，就需要这个苹果吃一点，停下来再去吃一点另一个苹果，既然Add方法内部是需要分两步走，那就是线程A在0的位置赋了一个值，然后停下来去B线程ArrayList 0的位置又赋了一个值，其实是重复在一个位置赋值，然后回到A线程，执行Size增加，也就是ArrayList的大小增加了，原来Size是1，现在变成2，然后停下来继续执行线程B，又增加了一个空间位置，size大小就变成了3，结果就是0的位置有值，1和2的索引位置都没有值实际大小是3，跟想要的结果0和1赋不同的值，结果不对，so线程不安全。</p><p>解决线程不安全的方法：</p><ol><li><p>继承Arraylist，然后重写或按需求编写自己的方法，这些方法要写成synchronized，在这些synchronized的方法中调用ArrayList的方法。</p></li><li><p>List list = Collections.synchronizedList(new ArrayList());</p></li></ol><h3 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h3><p><code>LinkedList</code> 是基于链表设计的，而且是双向链表，所以它具有双向链表的特性。</p><ul><li><p>链表无容量限制，但双向链表本身使用了更多空间，也需要额外的链表指针操作。</p></li><li><p>除了实现 <code>List</code> 接口外，LinkedList还为在列表的开头及结尾 <code>get、remove和insert</code> 元素提供了统一的命名方法。这些操作可以将链接列表当作栈，队列和双端队列来使用。</p></li></ul><p>从源码上看，<code>LinkedList</code> 继承的类与实现的接口如下</p><p><code>Collection</code> 接口、<code>List</code> 接口、<code>Cloneable</code> 接口、<code>Serializable</code> 接口、<code>Deque</code> 接口（5个接口）</p><p><code>AbstractCollection</code> 类、<code>AbstractList</code> 类、<code>AbstractSequentialList</code> 类（3个类） 。</p><p>其中 <code>Deque</code> 定义了一个线性 <code>Collection</code> ，支持在两端插入和删除元素。</p><h4 id="API操作"><a href="#API操作" class="headerlink" title="API操作"></a>API操作</h4><ol><li><p>节点Node结构</p><pre><code> private static class Node&lt;E&gt; &#123;         E item;//元素值         Node&lt;E&gt; next;//后置节点         Node&lt;E&gt; prev;//前置节点         Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;             this.item = element;             this.next = next;             this.prev = prev;         &#125; &#125;</code></pre></li></ol><ol start="2"><li><p>构造方法</p><pre><code> public LinkedList() &#123;&#125; //调用addAll(c)  表示将集合c所有元素插入链表中 public LinkedList(Collection&lt;? extends E&gt; c) &#123;     this();     addAll(c); &#125;</code></pre></li></ol><p>下面实际用例来看看具体是怎么增删改查的。</p><pre><code>    public static void main(String[] args) &#123;        LinkedList&lt;Integer&gt; list = new LinkedList&lt;Integer&gt;();        list.add(1);//增加一个节点        list.add(3);        list.add(4);        System.out.println(list);// [1, 3, 4]        list.add(1, 2);// 在1处插入2        System.out.println(list);// [1, 2, 3, 4]        list.remove(0);// 删除第一个元素        System.out.println(list);// [2, 3, 4]        list.set(0,1);// 将0位设置为1        System.out.println(list);// [1, 3, 4]        Integer a = list.get(0);        System.out.println(a);// 1    &#125;</code></pre><p><a href="https://www.runoob.com/java/java-linkedlist.html">更多方法</a></p><p>下面看一下 <code>LinkedList</code> 的一般的遍历</p><ol><li>一般的for循环(随机访问)<pre><code> int size = list.size(); for (int i=0; i&lt;size; i++) &#123;     list.get(i);         &#125;</code></pre></li></ol><ol start="2"><li><p>for–each循环</p><pre><code> for (Integer integ:list) </code></pre></li></ol><ol start="3"><li>迭代器iterator<pre><code> for(Iterator iter = list.iterator(); iter.hasNext();)     iter.next();</code></pre></li></ol><h4 id="小结"><a href="#小结" class="headerlink" title="小结:"></a>小结:</h4><ol><li><p>底层实现：LinkedList的实现是基于双向链表的，且头结点中不存放数据</p></li><li><p>构造方法：无参构造方法直接建立一个仅包含head节点的空链表；包含Collection的构造方法，先调用无参构造方法建立一个空链表，而后将Collection中的数据加入到链表的尾部后面。</p></li><li><p>查找删除：源码中都划分为该元素为null和不为null两种情况来处理，LinkedList中允许元素为null。</p></li><li><p>LinkedList是基于链表实现的，因此不存在容量不足的问题，所以这里没有扩容的方法。</p></li><li><p>LinkedList是基于链表实现的，因此插入删除效率高，查找效率低（虽然有一个加速动作）。</p></li><li><p>注意源码中还实现了栈和队列的操作方法，因此也可以作为栈、队列和双端队列来使用。</p></li></ol><h3 id="ArrayList-和-LinkedList-异同"><a href="#ArrayList-和-LinkedList-异同" class="headerlink" title="ArrayList 和 LinkedList 异同"></a>ArrayList 和 LinkedList 异同</h3><p><strong>相同点</strong>：</p><ol><li><p>接口实现：都实现了List接口，都是线性列表的实现</p></li><li><p>线程安全：都是线程不安全的，都是基于fail-fast机制</p></li></ol><p><strong>不同点</strong>：</p><ol><li><p>底层:ArrayList内部是数组实现，而LinkedList内部实现是双向链表结构</p></li><li><p>接口：ArrayList实现了RandomAccess可以支持随机元素访问，而LinkedList实现了Deque可以当做队列使用</p></li><li><p>性能：新增、删除元素时ArrayList需要使用到拷贝原数组，而LinkedList只需移动指针，查找元素 ArrayList支持随机元素访问,而LinkedList只能一个节点的去遍历</p></li></ol><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://zhuanlan.zhihu.com/p/24247566">https://zhuanlan.zhihu.com/p/24247566</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span><a href="https://www.runoob.com/java/java-arraylist.html">https://www.runoob.com/java/java-arraylist.html</a><a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
      <category>Java</category>
      
      <category>Java基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编程语言的运用</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>动态规划:最长子数组和系列</title>
    <link href="/2021/03/02/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E6%9C%80%E9%95%BF%E5%AD%90%E6%95%B0%E7%BB%84%E5%92%8C%E7%B3%BB%E5%88%97/"/>
    <url>/2021/03/02/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E6%9C%80%E9%95%BF%E5%AD%90%E6%95%B0%E7%BB%84%E5%92%8C%E7%B3%BB%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h2 id="动态规划-最长子数组和系列"><a href="#动态规划-最长子数组和系列" class="headerlink" title="动态规划:最长子数组和系列"></a>动态规划:最长子数组和系列</h2><span id="more"></span><p>官方解释: 从动态规划角度讲，最大子数组和是以一类较简单的 <code>DP</code> 问题，但它的状态设计比较经典，同时也是很多问题的基础组件，需要专门掌握。</p><p>果然是我太菜了</p><h3 id="1-最大子序和"><a href="#1-最大子序和" class="headerlink" title="1. 最大子序和"></a>1. 最大子序和</h3><p><a href="https://leetcode-cn.com/problems/maximum-subarray/">刷题地址 53. 最大子序和</a></p><p>给定一个整数数组 <code>nums</code> ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p><p><strong>示例 1</strong>：</p><pre><code>输入：nums = [-2,1,-3,4,-1,2,1,-5,4]输出：6解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。</code></pre><p><strong>示例 2</strong>：</p><pre><code>输入：nums = [1]输出：1</code></pre><p><strong>提示</strong>：</p><pre><code>1 &lt;= nums.length &lt;= 3 * 10e4-105 &lt;= nums[i] &lt;= 10e5</code></pre><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>该系列最经典的一题，也是最简单的一题，思路也很简单。思路清晰，先说DP。</p><ol><li>对数组遍历，连续子序列和为 <code>sum</code></li><li>如果 <code>sum&gt;0</code> 就说明对结果有增益</li><li>如果小于0就表示没有增益，直接舍去前面的结果，将 <code>sum</code> 赋值为 <code>nums[i]</code>。</li><li>记录每次遍历是sum的最大值</li></ol><p>代码还是很简洁的</p><h4 id="代码-Java"><a href="#代码-Java" class="headerlink" title="代码(Java)"></a>代码(Java)</h4><pre><code>class Solution &#123;    public int maxSubArray(int[] nums) &#123;        int len = nums.length;        if(len&lt;1) return 0;        int sum = 0;        int res = Integer.MIN_VALUE;        for(int i=0;i&lt;len;i++)&#123;            if(sum&gt;0)&#123;                sum += nums[i];            &#125;else&#123;                sum = nums[i];            &#125;            res = Math.max(res, sum);        &#125;        return res;    &#125;&#125;</code></pre><h3 id="2-乘积最大子数组"><a href="#2-乘积最大子数组" class="headerlink" title="2. 乘积最大子数组"></a>2. 乘积最大子数组</h3><p><a href="https://leetcode-cn.com/problems/maximum-product-subarray/">刷题地址:152. 乘积最大子数组</a></p><p>给你一个整数数组 <code>nums</code> ，请你找出数组中乘积最大的连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。</p><p><strong>示例 1</strong>：</p><pre><code>输入: [2,3,-2,4] 输出: 6解释: 子数组 [2,3] 有最大乘积 6。</code></pre><p><strong>示例 2</strong>:</p><pre><code>输入: [-2,0,-1]输出: 0解释: 结果不能为 2, 因为 [-2,-1] 不是子数组。</code></pre><h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p>和上一题差不多，但是我们要注意，如果遇到负数的话，最大值乘负数会变成最小值，相对应的，最小值乘负数也会变成最大值。我们需要在每次遍历时候记录最大值和最小值，在 <code>nums[i]</code> 为负数时，调换最大值和最小值的数值。</p><h4 id="代码-Java-1"><a href="#代码-Java-1" class="headerlink" title="代码(Java)"></a>代码(Java)</h4><pre><code>class Solution &#123;    public int maxProduct(int[] nums) &#123;        int len = nums.length;        if(len==0) return 0;        int res = Integer.MIN_VALUE;        int imax = 1, imin = 1;        for(int i=0;i&lt;len;i++)&#123;            if(nums[i]&lt;0)&#123;                int temp = imax;                imax = imin;                imin = temp;            &#125;            imax = Math.max(imax*nums[i], nums[i]);            imin = Math.min(imin*nums[i], nums[i]);            res = Math.max(imax, res);        &#125;        return res;    &#125;&#125;</code></pre><h3 id="3-环形子数组的最大和"><a href="#3-环形子数组的最大和" class="headerlink" title="3. 环形子数组的最大和"></a>3. 环形子数组的最大和</h3><p>给定一个由整数数组 A 表示的环形数组 C，求 C 的非空子数组的最大可能和。</p><p>在此处，环形数组意味着数组的末端将会与开头相连呈环状。（形式上，当 <code>0 &lt;= i &lt; A.length</code> 时 <code>C[i] = A[i]</code>，且当 <code>i &gt;= 0</code> 时 <code>C[i+A.length] = C[i]</code>）</p><p>此外，子数组最多只能包含固定缓冲区 A 中的每个元素一次。（形式上，对于子数组 <code>C[i], C[i+1], ..., C[j]</code>，不存在 <code>i &lt;= k1, k2 &lt;= j</code> 其中 <code>k1 % A.length = k2 % A.length</code>）</p><p><strong>示例 1</strong>：</p><pre><code>输入：[1,-2,3,-2]输出：3解释：从子数组 [3] 得到最大和 3</code></pre><p><strong>示例 2</strong>：</p><pre><code>输入：[5,-3,5]输出：10解释：从子数组 [5,5] 得到最大和 5 + 5 = 10</code></pre><p><strong>示例 3</strong>：</p><pre><code>输入：[3,-1,2,-1]输出：4解释：从子数组 [2,-1,3] 得到最大和 2 + (-1) + 3 = 4</code></pre><h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><p>思路清晰，先说DP。<br>稍微变通一下就是很简单的一道题，因为只包含两种情况，一种就是第一题的情况，另一种其实就是肯定包括第一位和最后一位，找出最大的子数组其实也就是找到第二位和倒数第二位之间最小的连续子序列，然后用总和减去即可。</p><h4 id="代码-Java-2"><a href="#代码-Java-2" class="headerlink" title="代码(Java)"></a>代码(Java)</h4><pre><code>class Solution &#123;    public int maxSubarraySumCircular(int[] A) &#123;        int sum = 0;        int len = A.length;        if(len&lt;1) return 0;        if(len == 1) return A[0];        int s1 = 0;        int ans1 = Integer.MIN_VALUE;        for(int i=0;i&lt;len;i++)&#123;            sum += A[i];            s1 = Math.max(s1+A[i], A[i]);            ans1 = Math.max(s1, ans1);        &#125;        int s2 = 0;        int ans2 = Integer.MAX_VALUE;        for(int i=1;i&lt;len-1;i++)&#123;            s2 = Math.min(s2+A[i], A[i]);            ans2 = Math.min(ans2, s2);        &#125;        ans2 = sum - ans2;        return Math.max(ans1, ans2);    &#125;&#125;</code></pre><h3 id="4-最大子矩阵"><a href="#4-最大子矩阵" class="headerlink" title="4. 最大子矩阵"></a>4. 最大子矩阵</h3><p><a href="https://leetcode-cn.com/problems/max-submatrix-lcci/">刷题地址:面试题 17.24. 最大子矩阵</a></p><p>给定一个正整数、负整数和 0 组成的 N × M 矩阵，编写代码找出元素总和最大的子矩阵。</p><p>返回一个数组 <code>[r1, c1, r2, c2]</code> ，其中 <code>r1</code>, <code>c1</code> 分别代表子矩阵左上角的行号和列号，<code>r2</code>, <code>c2</code> 分别代表右下角的行号和列号。若有多个满足条件的子矩阵，返回任意一个均可。</p><p>注意：本题相对书上原题稍作改动</p><p><strong>示例</strong>：</p><pre><code>输入：[   [-1,0],   [0,-1]]输出：[0,1,0,1]解释：输入中标粗的元素即为输出所表示的矩阵</code></pre><h4 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h4><p>看着挺唬人的一道题，也还是第一道题的二维化，我们遍历两次从第 <code>i</code> 行开始的 <code>j</code> 行，每一列的数加在一起变成了一个新的数组 <code>b[]</code>，然后算b的最大连续子序列，同时记录下左上的坐标，在每次出现最大值时更新右下坐标即可，思路还是很清晰的。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><pre><code>class Solution &#123;    public int[] getMaxMatrix(int[][] matrix) &#123;        int []ans = new int [4];        int lenx = matrix.length;        int leny = matrix[0].length;        int []b = new int[leny];        int row = 0, col = 0;        int max = Integer.MIN_VALUE;        for(int i=0;i&lt;lenx;i++)&#123;            Arrays.fill(b, 0);            for(int j=i;j&lt;lenx;j++)&#123;                int sum = 0;                for(int k=0;k&lt;leny;k++)&#123;                    b[k] += matrix[j][k];                    if(sum&gt;0)&#123;                        sum += b[k];                    &#125;else&#123;                        sum = b[k];                        row = i;                        col = k;                    &#125;                    if(sum &gt; max)&#123;                        max = sum;                        ans[0] = row;                        ans[1] = col;                        ans[2] = j;                        ans[3] = k;                    &#125;                &#125;            &#125;        &#125;        return ans;    &#125;&#125;</code></pre><h3 id="5-矩形区域不超过-K-的最大数值和"><a href="#5-矩形区域不超过-K-的最大数值和" class="headerlink" title="5. 矩形区域不超过 K 的最大数值和"></a>5. 矩形区域不超过 K 的最大数值和</h3><p><a href="https://leetcode-cn.com/problems/max-sum-of-rectangle-no-larger-than-k/">刷题地址:363. 矩形区域不超过 K 的最大数值和</a></p><p>给定一个非空二维矩阵 matrix 和一个整数 k，找到这个矩阵内部不大于 k 的最大矩形和。</p><pre><code>输入: matrix = [[1,0,1],[0,-2,3]], k = 2输出: 2 解释: 矩形区域 [[0, 1], [-2, 3]] 的数值和是 2，且 2 是不超过 k 的最大数字（k = 2）。</code></pre><h4 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h4><p>思路清晰，先不说DP，就是上面一道题的变体，最接近 <code>k</code> 而不大于 <code>k</code>, 直接对上一题的 <code>b[]</code> 进行暴力遍历咯，找到所有情况直接选择最优解。</p><p>PS：实际情况因为一般都要查询多次，为避免重复计算一般选用二维前缀和，在前缀和篇章细嗦。</p><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><pre><code>class Solution &#123;    public int maxSumSubmatrix(int[][] matrix, int k) &#123;        int res = Integer.MIN_VALUE;        int lenx = matrix.length;        int leny = matrix[0].length;        int []b = new int[leny];                for(int i=0;i&lt;lenx;i++)&#123;            Arrays.fill(b, 0);            for(int j=i;j&lt;lenx;j++)&#123;                for(int l=0;l&lt;leny;l++)&#123;                    b[l] += matrix[j][l];                &#125;                for(int x=0;x&lt;leny;x++)&#123;                    int sum = 0;                    for(int y=x;y&lt;leny;y++)&#123;                        sum += b[y];                        if(sum&lt;=k)&#123;                            res = Math.max(res, sum);                        &#125;                    &#125;                &#125;            &#125;        &#125;        return res;    &#125;&#125; </code></pre>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
      <category>动态规划</category>
      
      <category>单串问题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode124.二叉树中的最大路径和</title>
    <link href="/2021/03/01/leetcode124-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E8%B7%AF%E5%BE%84%E5%92%8C/"/>
    <url>/2021/03/01/leetcode124-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E8%B7%AF%E5%BE%84%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<h2 id="leetcode124-二叉树中的最大路径和"><a href="#leetcode124-二叉树中的最大路径和" class="headerlink" title="leetcode124.二叉树中的最大路径和"></a>leetcode124.二叉树中的最大路径和</h2><span id="more"></span><p><a href="https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/">刷题地址</a></p><p><strong>路径</strong> 被定义为一条从树中任意节点出发，沿父节点-子节点连接，达到任意节点的序列。同一个节点在一条路径序列中  <strong>至多出现一次</strong> 。该路径 <strong>至少包含一个</strong> 节点，且不一定经过根节点。</p><p><strong>路径和</strong> 是路径中各节点值的总和。</p><p>给你一个二叉树的根节点 <code>root</code> ，返回其 <strong>最大路径和</strong> 。</p><p><strong>示例1</strong>：</p><pre><code>输入：root = [1,2,3]输出：6解释：最优路径是 2 -&gt; 1 -&gt; 3 ，路径和为 2 + 1 + 3 = 6</code></pre><p><strong>示例2</strong>：</p><pre><code>输入：root = [-10,9,20,null,null,15,7]输出：42解释：最优路径是 15 -&gt; 20 -&gt; 7 ，路径和为 15 + 20 + 7 = 42</code></pre><p><code>root</code> 对象所在的类：</p><pre><code>public class TreeNode &#123;     int val;     TreeNode left;     TreeNode right;     TreeNode() &#123;&#125;     TreeNode(int val) &#123; this.val = val; &#125;     TreeNode(int val, TreeNode left, TreeNode right) &#123;         this.val = val;         this.left = left;         this.right = right;     &#125;&#125;</code></pre><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>一个比较经典的递归题，路径的含义通俗的来说就是在二叉树中没有分叉的线经过的子节点，只要满足不分叉，可以随意走。</p><p>我们考虑如果将问题缩小</p><p><img src="/img/leetcode/124.jpg" alt="leetcode124"></p><p>所有的路径情况就是</p><ul><li>左中右 <code>b + a + c</code></li><li>左 <code>b + a</code></li><li>右 <code>c + a</code></li></ul><p>用递归方法</p><ul><li>递归调用 <code>b</code> 和 <code>c</code></li><li>计算 <code>b + a</code> 和 <code>c + a</code>，选择较大的值作为返回值</li><li>更新到结果(全局最大和)</li></ul><p>即：<code>f(n) = max(max(0, f(n-&gt;left)) + n-&gt;val, max(0, f(n-&gt;right))+n-&gt;val)</code></p><p>如果节点的数值是负数，应当能舍就舍，即不走该路径 <code>max(0, x)</code> 。如果是不能绕过的根节点，其实可以直接先设置全局最大和为 <code>INT_MIN</code> 即 <code>-pow(2, 32)</code> 这样更新的时候也就没问题了。</p><p>这么一想，代码就容易多了。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre><code>class Solution &#123;    int res = Integer.MIN_VALUE;    public int f(TreeNode root)&#123;        if(root==null) return 0;//显然没有节点就是0        int left = Math.max(0, f(root.left));        int right = Math.max(0, f(root.right));        int count = left + right + root.val;        res = Math.max(res, count);        return Math.max(left+root.val, right+root.val);    &#125;    public int maxPathSum(TreeNode root) &#123;        f(root);        return res;    &#125;&#125;</code></pre><p><img src="/img/leetcode/124result.jpg" alt="result"></p>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
      <category>二叉树</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>递归</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>接口与多态(中)</title>
    <link href="/2021/03/01/%E6%8E%A5%E5%8F%A3%E4%B8%8E%E5%A4%9A%E6%80%81-%E4%B8%AD/"/>
    <url>/2021/03/01/%E6%8E%A5%E5%8F%A3%E4%B8%8E%E5%A4%9A%E6%80%81-%E4%B8%AD/</url>
    
    <content type="html"><![CDATA[<h2 id="接口与多态-中"><a href="#接口与多态-中" class="headerlink" title="接口与多态(中)"></a>接口与多态(中)</h2><span id="more"></span><p>让我们来看看常见而实用的接口，下面的接口一定要理解并弄明白。</p><h3 id="1-Serializable"><a href="#1-Serializable" class="headerlink" title="1. Serializable"></a>1. Serializable</h3><p>一个对象序列化的接口，一个类只有实现了Serializable接口，它的对象才能被序列化。</p><h4 id="什么是序列化？"><a href="#什么是序列化？" class="headerlink" title="什么是序列化？"></a>什么是序列化？</h4><p>序列化是将对象状态转换为可保持或传输的格式的过程。与序列化相对的是反序列化，它将流转换为对象。这两个过程结合起来，可以轻松地存储和传输数据。</p><p>当我们需要把对象的状态信息通过网络进行传输，或者需要将对象的状态信息持久化，以便将来使用时都需要把对象进行序列化。</p><p><code>Serializable</code> 在源码上也只是一个声明，就是告知JVM，让JVM帮助这个类进行序列化，而自己不用具体去写方法。</p><h4 id="为什么要定义serialversionUID变量"><a href="#为什么要定义serialversionUID变量" class="headerlink" title="为什么要定义serialversionUID变量"></a>为什么要定义serialversionUID变量</h4><p>如果我们标识了 <code>Serializable</code> 却没有具体实现，接口会默认生成一个 <code>serialVersionUID</code> 变量，但是接口端的 <code>serialVersionUID</code> 异常敏感，反序列化可能导致异常，所以建议自己定义一个 <code>serialVersionUID</code>。</p><p>下面看一段示例</p><pre><code>public class Employee implements Serializable &#123;    private static final long serialVersionUID = 1L;    private int age;    private int salary;    private String name;    public void setAge(int age) &#123;        this.age = age;    &#125;    public void setSalary(int salary) &#123;        this.salary = salary;    &#125;    public void setName(String name) &#123;        this.name = name;    &#125;    @Override    public String toString() &#123;        return &quot;Employee&#123;&quot; +                &quot;age=&quot; + age +                &quot;, salary=&quot; + salary +                &quot;, name=&#39;&quot; + name + &#39;\&#39;&#39; +                &#39;&#125;&#39;;    &#125;&#125;public class Main &#123;    public static void writeEmployee()&#123;        try&#123;            Employee em = new Employee();            em.setAge(18);            em.setName(&quot;abc&quot;);            em.setSalary(10000);            ObjectOutputStream objectOutputStream = new ObjectOutputStream(new FileOutputStream(new File(&quot;abc&quot;)));            objectOutputStream.writeObject(em);            System.out.println(&quot;序列化成功&quot;);            objectOutputStream.close();        &#125; catch (Exception ex) &#123;            System.out.println(&quot;WriteEmployee&quot; + ex.getMessage());        &#125;    &#125;    private static Employee readEmployee()&#123;        Employee me = null;        try&#123;            ObjectInputStream objectInputStream = new ObjectInputStream(new FileInputStream(new File(&quot;abc&quot;)));            me = (Employee) objectInputStream.readObject();            System.out.println(&quot;反序列化成功&quot;);            System.out.println(me);        &#125;catch (Exception ex)&#123;            System.out.println(&quot;readEmployee:&quot;+ex.getMessage());        &#125;        return me;    &#125;    public static void main(String[] args) throws Exception &#123;        writeEmployee();        readEmployee();    &#125;&#125;</code></pre><p>结果</p><pre><code>序列化成功反序列化成功Employee&#123;age=18, salary=10000, name=&#39;abc&#39;&#125;</code></pre><p>如果没 <code>serialversionUID</code> 在反序列化时候就回抛出异常，这个 <code>serialVersionUID</code> 的详细的工作机制是：在序列化的时候系统将 <code>serialVersionUID</code> 写入到序列化的文件中去，当反序列化的时候系统会先去检测文件中的 <code>serialVersionUID</code> 是否跟当前的文件的 <code>serialVersionUID</code> 是否一致，如果一直则反序列化成功，否则就说明当前类跟序列化后的类发生了变化，比如是成员变量的数量或者是类型发生了变化，那么在反序列化时就会发生 <code>crash</code> ，并且回报出错误。</p><h3 id="2-Comparable-和-Comparator"><a href="#2-Comparable-和-Comparator" class="headerlink" title="2. Comparable 和 Comparator"></a>2. Comparable 和 Comparator</h3><p>顾名思义咯，俩兄弟都是比较两个对象用的，要的是学习两个独特的用法和区别。</p><h4 id="Comparable"><a href="#Comparable" class="headerlink" title="Comparable"></a>Comparable</h4><p>先看源码</p><pre><code>public interface Comparable&lt;T&gt; &#123;    int compareTo(T t);&#125;</code></pre><p>所以如果一个类实现了 <code>Comparable</code> 接口，一定需要重写 <code>compareTo</code> 方法，用自己给定的规则对两个创建的对象进行比较。</p><p>示例</p><pre><code>public class Employee implements Comparable&lt;Employee&gt; &#123;    private static final long serialVersionUID = 1L;    private int age;    private int salary;    private String name;    public Employee(int age, int salary, String name) &#123;        this.age = age;        this.salary = salary;        this.name = name;    &#125;    @Override    public int compareTo(Employee o) &#123;        return this.salary - o.salary;    &#125;    public static void main(String[] args) &#123;        Employee a = new Employee(18, 100, &quot;A&quot;);        Employee b = new Employee(18, 101, &quot;B&quot;);        if(a.compareTo(b)&gt;0)&#123;            System.out.println(a.name+&quot;工资高&quot;);        &#125;else if(a.compareTo(b)==0)&#123;            System.out.println(&quot;一样高&quot;);        &#125;else&#123;            System.out.println(b.name+&quot;工资高&quot;);        &#125;    &#125;&#125;</code></pre><p>结果</p><pre><code>B工资高</code></pre><p>我们看 <code>Comparable</code> 接口还是比较简单的，只需要实现 <code>comparaTo</code> 方法即可，如果指定对象的类型与此对象不能进行比较，则引发 <code>ClassCastException</code> 异常（引入泛型可以规避这种情况）。</p><h4 id="Comparator"><a href="#Comparator" class="headerlink" title="Comparator"></a>Comparator</h4><p>先看一下源码</p><pre><code>public class CmowerComparator implements Comparator&lt;Cmower&gt; &#123;    @Override    public int compare(Cmower o1, Cmower o2) &#123;        return o1.getAge() - o2.getAge();    &#125;&#125;</code></pre><p>实际上是要你重写类，以及如何比较的方法，举个例子。</p><pre><code>public class Employee &#123;    private int age;    private int salary;    private String name;    public Employee(int age, int salary, String name) &#123;        this.age = age;        this.salary = salary;        this.name = name;    &#125;    public int getSalary() &#123;        return salary;    &#125;    public String getName() &#123;        return name;    &#125;    public static void main(String[] args) &#123;        Employee a = new Employee(18, 100, &quot;A&quot;);        Employee b = new Employee(18, 101, &quot;B&quot;);        Employee c = new Employee(18, 99, &quot;C&quot;);        List&lt;Employee&gt; list = new ArrayList&lt;&gt;();        list.add(a);        list.add(b);        list.add(c);        list.sort(new EmployeeComparator());        for(Employee i:list)&#123;            System.out.println(i.getName());        &#125;    &#125;&#125;class EmployeeComparator implements Comparator&lt;Employee&gt;&#123;    @Override    public int compare(Employee o1, Employee o2) &#123;        return o1.getSalary() - o2.getSalary();    &#125;&#125;</code></pre><p>结果</p><pre><code>CAB</code></pre><p>显然，已经按照工资的顺序排列了。</p><p><code>Comparator</code> 的具体作用就是判断大小的基础上应用如排序方法。</p><h4 id="二者区别"><a href="#二者区别" class="headerlink" title="二者区别"></a>二者区别</h4><ul><li><p>一个类实现了 <code>Comparable</code> 接口，意味着该类的对象可以直接进行比较（排序），但比较（排序）的方式只有一种，很单一。</p></li><li><p>一个类如果想要保持原样，又需要进行不同方式的比较（排序），就可以定制比较器（实现 <code>Comparator</code> 接口）。</p></li><li><p><code>Comparable</code> 接口在 <code>java.lang</code> 包下，而 <code>Comparator</code> 接口在 <code>java.util</code> 包下，算不上是亲兄弟，但可以称得上是表（堂）兄弟。</p></li></ul><h3 id="3-Cloneable"><a href="#3-Cloneable" class="headerlink" title="3. Cloneable"></a>3. Cloneable</h3><p>标记一个类是可以深复制的，在<a href="https://www.dmxcg.xyz/2021/02/25/%E4%B8%80%E5%88%87%E7%9A%86%E5%AF%B9%E8%B1%A1-Object%E7%B1%BB%E7%9A%8411%E4%B8%AA%E6%96%B9%E6%B3%95(%E4%B8%8A)/">另一篇博客</a>中讲到如何使用的方法。</p><h3 id="4-Iterable-和-Iterator"><a href="#4-Iterable-和-Iterator" class="headerlink" title="4. Iterable 和 Iterator"></a>4. Iterable 和 Iterator</h3><p>先看源码</p><pre><code>public interface Iterable&lt;T&gt; &#123;  Iterator&lt;T&gt; iterator();&#125;public interface Iterator&lt;E&gt; &#123;  boolean hasNext();  E next();  void remove();&#125;</code></pre><p><code>Interable</code> 只是返回了 <code>Intertor</code> 的一个实例，原因是实现了 <code>Iterable</code> 的类可以在实现多个 <code>Iterator</code> 内部类，例如 <code>LinkedList</code> 中的 <code>ListItr</code> 和 <code>DescendingIterator</code> 两个内部类，就分别实现了双向遍历和逆序遍历。通过返回不同的Iterator实现不同的遍历方式，这样更加灵活。如果把两个接口合并，就没法返回不同的 <code>Iterator</code> 实现类了。</p><p>上个代码，直观地展示一下实现了 <code>Iterable</code> 的类如何通过返回不同的 <code>Iterator</code>  从而实现不同的遍历方式。  <code>MutilIterator</code> 实现了三种迭代器，分别是默认的前向迭代器，反向迭代器和随机迭代器。主函数中分别调用了三种迭代器进行遍历。</p><pre><code>public class MutilIterator implements Iterable&lt;String&gt;&#123;    private String[] words = &quot;May I get offers this summer.&quot;.split(&quot; &quot;);    // 默认迭代器，前向遍历    @Override    public Iterator&lt;String&gt; iterator() &#123;        return new Iterator&lt;String&gt;() &#123;            private int index = 0;            @Override            public boolean hasNext() &#123;                return index &lt; words.length;            &#125;            @Override            public String next() &#123;                return words[index++];            &#125;        &#125;;    &#125;    // 反向迭代器    public Iterable&lt;String&gt; reverseItertor()&#123;        return new Iterable&lt;String&gt;() &#123;            @Override            public Iterator&lt;String&gt; iterator() &#123;                return new Iterator&lt;String&gt;() &#123;                    private int index = words.length - 1;                    @Override                    public boolean hasNext() &#123;                        return index&gt;-1;                    &#125;                    @Override                    public String next() &#123;                        return words[index--];                    &#125;                &#125;;            &#125;        &#125;;    &#125;    //随机迭代器，注意这里不是创建一个新的Iterator，而是返回了一个打乱的List中的迭代器    public Iterable&lt;String&gt; randomized()&#123;        return new Iterable&lt;String&gt;() &#123;            @Override            public Iterator&lt;String&gt; iterator() &#123;                List&lt;String&gt; shuffled = new ArrayList&lt;&gt;(Arrays.asList(words));                Collections.shuffle(shuffled, new Random(47));                return shuffled.iterator();            &#125;        &#125;;    &#125;    public static void main(String[] args) &#123;        MutilIterator mi = new MutilIterator();        for(String i:mi)&#123;            System.out.print(i + &quot; &quot;);        &#125;        System.out.println();        for(String i:mi.reverseItertor())&#123;            System.out.print(i + &quot; &quot;);        &#125;        System.out.println();        for(String i:mi.randomized())&#123;            System.out.print(i + &quot; &quot;);        &#125;    &#125;&#125;</code></pre><p>以上就是三个常见的迭代器的用法。</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://zhuanlan.zhihu.com/p/101583223">来吧，一文彻底搞懂Java中的Comparable和Comparator</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span><a href="https://www.zhihu.com/question/271757053/answer/363282519">知乎回答</a><a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
      <category>Java</category>
      
      <category>Java基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编程语言的运用</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>接口与多态(String专场)</title>
    <link href="/2021/02/28/%E6%8E%A5%E5%8F%A3%E4%B8%8E%E5%A4%9A%E6%80%81-String%E4%B8%93%E5%9C%BA/"/>
    <url>/2021/02/28/%E6%8E%A5%E5%8F%A3%E4%B8%8E%E5%A4%9A%E6%80%81-String%E4%B8%93%E5%9C%BA/</url>
    
    <content type="html"><![CDATA[<h2 id="接口与多态-String专场"><a href="#接口与多态-String专场" class="headerlink" title="接口与多态(String专场)"></a>接口与多态(String专场)</h2><span id="more"></span><p>多态讲的差不多了，下面介绍一些常见常用需要掌握的接口，学会这些会使咱专业水平突飞猛进。</p><h3 id="String类"><a href="#String类" class="headerlink" title="String类"></a>String类</h3><p>就是一个常见而特殊的接口，一共有几十种方法可以使用</p><p>先看一下如果初始化一个字符串</p><pre><code>String s1 = &quot;Runoob&quot;;              // String 直接创建String s2 = &quot;Runoob&quot;;              // String 直接创建String s3 = s1;                    // 相同引用String s4 = new String(&quot;Runoob&quot;);   // String 对象创建String s5 = new String(&quot;Runoob&quot;);   // String 对象创建</code></pre><p>根据学过的知识，我们知道在 <code>JVM</code> 中，地址如下</p><p><img src="/img/Java/Object/JVM3.jpg" alt="JVM"></p><p>我们同样可以这样来初始化 <code>String</code> </p><pre><code>  char[] helloArray = &#123;&#39;H&#39;, &#39;e&#39;, &#39;l&#39;, &#39;l&#39;, &#39;o&#39;&#125; ;  String helloString = new String(helloArray);</code></pre><p>下面介绍 <code>String</code> 类支持的方法</p><p>我们定义一个字符串 <code>s = &quot;Hello&quot;</code>。</p><h4 id="1-charAt"><a href="#1-charAt" class="headerlink" title="1. charAt()"></a>1. charAt()</h4><pre><code>public char charAt(int index)</code></pre><p>就是返回 <code>index</code> 索引处的字符</p><pre><code>System.out.println(s.charAt(0));</code></pre><p>结果<br>    H</p><h4 id="2-comparaTo-和-compareToIgnoreCase"><a href="#2-comparaTo-和-compareToIgnoreCase" class="headerlink" title="2. comparaTo() 和 compareToIgnoreCase()"></a>2. comparaTo() 和 compareToIgnoreCase()</h4><p> <code>comparaTo()</code> 方法用于两个字符串的比较</p><ul><li><p>按字典顺序比较两个字符串。</p><p>  int compareTo(String anotherString)</p></li></ul><p>返回值是整型，它是先比较对应字符的大小(ASCII码顺序)，如果第一个字符和参数的第一个字符不等，结束比较，返回他们之间的长度差值，如果第一个字符和参数的第一个字符相等，则以第二个字符和参数的第二个字符做比较，以此类推,直至比较的字符或被比较的字符有一方结束。</p><pre><code>public class Test &#123;     public static void main(String args[]) &#123;        String str1 = &quot;Strings&quot;;        String str2 = &quot;Strings&quot;;        String str3 = &quot;Strings123&quot;;         int result = str1.compareTo( str2 );        System.out.println(result);              result = str2.compareTo( str3 );        System.out.println(result);             result = str3.compareTo( str1 );        System.out.println(result);    &#125;&#125;</code></pre><p>结果</p><pre><code>0-33</code></pre><p><code>comparaToIngoreCase()</code> 就是忽略大小写的 <code>comparaTo()</code>。</p><h4 id="3-concat"><a href="#3-concat" class="headerlink" title="3. concat()"></a>3. concat()</h4><p>连接两个字符串</p><pre><code>    String a = &quot;Hello&quot;;    String b = &quot; World!&quot;;    System.out.println(a.concat(b));</code></pre><p>结果</p><pre><code>Hello World!</code></pre><p>实际上和 <code>+</code> 效果一样。</p><h4 id="4-contentEquals"><a href="#4-contentEquals" class="headerlink" title="4. contentEquals()"></a>4. contentEquals()</h4><p>用于将此字符串与指定的 <code>StringBuffer</code> 比较。</p><pre><code>public boolean contentEquals(StringBuffer sb)</code></pre><p>如果该字符串与 <code>sb</code> 字符都相同就返回 <code>true</code> 否则 <code>false</code>。</p><h4 id="5-copyValueOf"><a href="#5-copyValueOf" class="headerlink" title="5. copyValueOf()"></a>5. copyValueOf()</h4><pre><code>public static String copyValueOf(char[] data)// 返回指定数组中表示该字符序列的字符串。或public static String copyValueOf(char[] data, int offset, int count)// 返回指定数组中表示该字符序列的 字符串。 </code></pre><p>即第一种就是把数组组合成字符串。第二种，就是截取，从 <code>offset</code> 开始的 <code>count</code> 位成为字符串。</p><pre><code>char[] Str1 = &#123;&#39;h&#39;, &#39;e&#39;, &#39;l&#39;, &#39;l&#39;, &#39;o&#39;, &#39; &#39;, &#39;w&#39;, &#39;o&#39;, &#39;r&#39;, &#39;l&#39;, &#39;d&#39;&#125;;String Str2 = &quot;&quot;;Str2 = String.copyValueOf(Str1);System.out.println(Str2);Str2 = String.copyValueOf(Str1, 1, 3);System.out.println(Str2);</code></pre><p>结果：</p><pre><code>hello worldell</code></pre><h4 id="6-endsWith-和startsWith"><a href="#6-endsWith-和startsWith" class="headerlink" title="6. endsWith()和startsWith()"></a>6. endsWith()和startsWith()</h4><p>endsWith() 方法用于测试字符串是否以指定的后缀结束。</p><pre><code>String str1 = &quot;Hello World&quot;;System.out.println(str1.endsWith(&quot;rld&quot;));System.out.println(str1.endsWith(&quot;abc&quot;));</code></pre><p>结果：</p><pre><code>truefalse</code></pre><p><code>startsWith()</code> 方法用于检测字符串是否以指定的前缀开始。参数方法就和 <code>endsWith()</code> 一样。</p><h4 id="7-equals-和equalsIgnoreCase"><a href="#7-equals-和equalsIgnoreCase" class="headerlink" title="7. equals()和equalsIgnoreCase()"></a>7. equals()和equalsIgnoreCase()</h4><p>老朋友了，<code>String</code> 的 <code>equals()</code> 是重写的，就是判断两个字符串是否相等。</p><p><code>equalsIgnoreCase()</code> 就是忽略大小写的 <code>equals()</code>。</p><h4 id="8-getChars"><a href="#8-getChars" class="headerlink" title="8. getChars()"></a>8. getChars()</h4><p>getChars() 方法将字符从字符串复制到目标字符数组。</p><pre><code>public void getChars(int srcBegin, int srcEnd, char[] dst,  int dstBegin)</code></pre><ul><li><p>srcBegin – 字符串中要复制的第一个字符的索引。</p></li><li><p>srcEnd – 字符串中要复制的最后一个字符之后的索引。</p></li><li><p>dst – 目标数组。</p></li><li><p>dstBegin – 目标数组中的起始偏移量。</p></li></ul><pre><code>String str1 = &quot;Hello World&quot;;char []str2 = new char[5];str1.getChars(0, 5, str2, 0);System.out.println(str2);</code></pre><p>结果</p><pre><code>Hello</code></pre><h4 id="9-hashCode"><a href="#9-hashCode" class="headerlink" title="9. hashCode()"></a>9. hashCode()</h4><p>hashCode() 方法用于返回字符串的哈希码。</p><p>计算方法：</p><pre><code>s[0]*31^(n-1) + s[1]*31^(n-2) + ... + s[n-1]</code></pre><p>在之前我们也说过，<code>hashCode</code> 还是辅助 <code>equals</code> 的。 <code>equals</code> 是 <code>hashCode</code> 相等的充分条件。</p><h4 id="10-indexOf-和lastIndexOf"><a href="#10-indexOf-和lastIndexOf" class="headerlink" title="10. indexOf()和lastIndexOf()"></a>10. indexOf()和lastIndexOf()</h4><ul><li><p>public int indexOf(int ch): 返回指定字符(ASCII)在字符串中第一次出现处的索引，如果此字符串中没有这样的字符，则返回 -1。</p></li><li><p>public int indexOf(int ch, int fromIndex): 返回从 fromIndex 位置开始查找指定字符在字符串中第一次出现处的索引，如果此字符串中没有这样的字符，则返回 -1。</p></li><li><p>int indexOf(String str): 返回指定字符在字符串中第一次出现处的索引，如果此字符串中没有这样的字符，则返回 -1。</p></li><li><p>int indexOf(String str, int fromIndex): 返回从 fromIndex 位置开始查找指定字符在字符串中第一次出现处的索引，如果此字符串中没有这样的字符，则返回 -1。</p></li></ul><pre><code>public int indexOf(int ch )或public int indexOf(int ch, int fromIndex)或int indexOf(String str)或int indexOf(String str, int fromIndex)</code></pre><p><code>lastIndexOf()</code> 就是返回最后一次索引，函数与上面完全相同</p><h4 id="11-intern"><a href="#11-intern" class="headerlink" title="11. intern()"></a>11. intern()</h4><p>看似没用的一个方法，返回值就是字符串，但是它会检查内存池中是否存在该字符串啊，如果没有，添加到内存池再返回其引用，如果有就直接返回该字符串的引用。</p><p>例如</p><pre><code>String str1 = &quot;a&quot;;String str2 = &quot;b&quot;;String str3 = str1 + str2;String str4 = new String(&quot;ab&quot;);System.out.println(str3==&quot;ab&quot;);System.out.println(str4==&quot;ab&quot;);</code></pre><p>结果</p><pre><code>falsefalse</code></pre><p>虽然 <code>str3</code>，<code>str4</code> 的值也是 <code>ab</code> 但是它并不在内存池中，如果使用 <code>intern()</code> 就会添加到内存池</p><pre><code>System.out.println(str3.intern()==&quot;ab&quot;);System.out.println(str4.intern()==&quot;ab&quot;);</code></pre><p>结果</p><pre><code>truetrue</code></pre><p>这个方法并不是持续的，即只有在调用这一刻，它是在内存池中的。</p><h4 id="12-length"><a href="#12-length" class="headerlink" title="12. length()"></a>12. length()</h4><p>就是返回字符串的长度，差不多是最常用的。</p><h4 id="13-regionMatches"><a href="#13-regionMatches" class="headerlink" title="13. regionMatches()"></a>13. regionMatches()</h4><p><code>regionMatches()</code> 方法用于检测两个字符串在一个区域内是否相等。</p><pre><code>public boolean regionMatches(boolean ignoreCase,                             int toffset,                             String other,                             int ooffset,                             int len)</code></pre><ul><li><p>ignoreCase – 如果为 true，则比较字符时忽略大小写。</p></li><li><p>toffset – 此字符串中子区域的起始偏移量。</p></li><li><p>other – 字符串参数。</p></li><li><p>ooffset – 字符串参数中子区域的起始偏移量。</p></li><li><p>len – 要比较的字符数。</p><p>  String s1 = “Hello World”;<br>  String s2 = “World”;</p><p>  System.out.println(s1.regionMatches(s1.indexOf(“W”), s2, 0, 5));</p></li></ul><p>结果</p><pre><code>true</code></pre><h4 id="14-replace"><a href="#14-replace" class="headerlink" title="14. replace()"></a>14. replace()</h4><pre><code>public String replace(char searchChar, char newChar)  </code></pre><p>替换所有 <code>searchChar</code> 字符为 <code>newChar</code></p><pre><code>String s1 = &quot;Hello World&quot;;System.out.println(s1.replace(&#39;o&#39;, &#39;O&#39;));</code></pre><p>结果</p><pre><code>HellO WOrld</code></pre><h4 id="15-subSequence"><a href="#15-subSequence" class="headerlink" title="15. subSequence()"></a>15. subSequence()</h4><p>subSequence() 方法返回一个新的字符序列，它是此序列的一个子序列。</p><pre><code>public CharSequence subSequence(int beginIndex, int endIndex)</code></pre><ul><li><p>beginIndex – 起始索引（包括）。</p></li><li><p>endIndex – 结束索引（不包括）。</p><p>  String s1 = “Hello World”;</p><p>  System.out.println(s1.subSequence(s1.indexOf(“H”), s1.indexOf(“ “)));</p></li></ul><p>结果</p><pre><code>Hello</code></pre><p>返回值是一个 <code>CharSequence</code> 字符序列，是 <code>String</code> 的超类</p><h4 id="16-substring"><a href="#16-substring" class="headerlink" title="16. substring()"></a>16. substring()</h4><pre><code>public String substring(int beginIndex)或public String substring(int beginIndex, int endIndex)</code></pre><ul><li><p>beginIndex – 起始索引（包括）, 索引从 0 开始。</p></li><li><p>endIndex – 结束索引（不包括）。</p></li></ul><p>用法和上面差不多</p><h4 id="17-toCharArray"><a href="#17-toCharArray" class="headerlink" title="17. toCharArray()"></a>17. toCharArray()</h4><p>转换为字符数组，很实用的一个类</p><pre><code>String s1 = &quot;Hello World&quot;;char []a = s1.toCharArray();for(char i:a)&#123;    System.out.print(i+&quot; &quot;);&#125;</code></pre><p>结果</p><pre><code>H e l l o   W o r l d </code></pre><p>PS: Java中，字符串是不能直接遍历进行修改的。</p><h4 id="18-toLowerCase-和toUpperCase"><a href="#18-toLowerCase-和toUpperCase" class="headerlink" title="18. toLowerCase()和toUpperCase()"></a>18. toLowerCase()和toUpperCase()</h4><p>顾名思义，就是把字符串中所有字符转换为小/大写</p><h4 id="19-trim"><a href="#19-trim" class="headerlink" title="19. trim()"></a>19. trim()</h4><p>用于删除字符串首尾的空白符</p><h4 id="20-valueOf"><a href="#20-valueOf" class="headerlink" title="20. valueOf()"></a>20. valueOf()</h4><p><code>valueOf</code> 就是让各种形式的参数变为字符串形式。</p><ul><li><p>valueOf(boolean b): 返回 boolean 参数的字符串表示形式。.</p></li><li><p>valueOf(char c): 返回 char 参数的字符串表示形式。</p></li><li><p>valueOf(char[] data): 返回 char 数组参数的字符串表示形式。</p></li><li><p>valueOf(char[] data, int offset, int count): 返回 char 数组参数的特定子数组的字符串表示形式。</p></li><li><p>valueOf(double d): 返回 double 参数的字符串表示形式。</p></li><li><p>valueOf(float f): 返回 float 参数的字符串表示形式。</p></li><li><p>valueOf(int i): 返回 int 参数的字符串表示形式。</p></li><li><p>valueOf(long l): 返回 long 参数的字符串表示形式。</p></li><li><p>valueOf(Object obj): 返回 Object 参数的字符串表示形式。</p></li></ul><h4 id="21-contains"><a href="#21-contains" class="headerlink" title="21. contains()"></a>21. contains()</h4><p>contains() 方法用于判断字符串中是否包含指定的字符或字符串。</p><pre><code>public boolean contains(CharSequence chars)</code></pre><h4 id="22-isEmpty"><a href="#22-isEmpty" class="headerlink" title="22. isEmpty()"></a>22. isEmpty()</h4><p>就是判读字符串是否为空。</p><pre><code>public boolean isEmpty()</code></pre><h4 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h4><p>常用的字符串方法基本就这么多，还有一些关于正则表达式的部分方法我们放在正则表达式专题细嗦。</p>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
      <category>Java</category>
      
      <category>Java基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编程语言的运用</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode第230场周赛(蓝湖)解析</title>
    <link href="/2021/02/28/leetcode%E7%AC%AC230%E5%9C%BA%E5%91%A8%E8%B5%9B-%E8%93%9D%E6%B9%96-%E8%A7%A3%E6%9E%90/"/>
    <url>/2021/02/28/leetcode%E7%AC%AC230%E5%9C%BA%E5%91%A8%E8%B5%9B-%E8%93%9D%E6%B9%96-%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="leetcode第230场周赛-蓝湖-解析"><a href="#leetcode第230场周赛-蓝湖-解析" class="headerlink" title="leetcode第230场周赛(蓝湖)解析"></a>leetcode第230场周赛(蓝湖)解析</h2><span id="more"></span><p><a href="https://leetcode-cn.com/contest/weekly-contest-230/">模拟竞赛地址</a></p><h3 id="第一题-统计匹配检索规则的物品数量"><a href="#第一题-统计匹配检索规则的物品数量" class="headerlink" title="第一题 统计匹配检索规则的物品数量"></a>第一题 统计匹配检索规则的物品数量</h3><p>给你一个数组 <code>items</code> ，其中 <code>items[i] = [typei, colori, namei]</code> ，描述第 <code>i</code> 件物品的类型、颜色以及名称。</p><p>另给你一条由两个字符串 <code>ruleKey</code> 和 <code>ruleValue</code> 表示的检索规则。</p><p>如果第 <code>i</code> 件物品能满足下述条件之一，则认为该物品与给定的检索规则 <strong>匹配</strong> ：</p><ul><li><code>ruleKey == &quot;type&quot;</code> 且 <code>ruleValue == typei</code> 。</li><li><code>ruleKey == &quot;color&quot;</code> 且 <code>ruleValue == colori</code> 。</li><li><code>ruleKey == &quot;name&quot;</code> 且 <code>ruleValue == namei</code> 。</li></ul><p><strong>示例 1</strong>：</p><pre><code>输入：items = [[&quot;phone&quot;,&quot;blue&quot;,&quot;pixel&quot;],[&quot;computer&quot;,&quot;silver&quot;,&quot;lenovo&quot;],[&quot;phone&quot;,&quot;gold&quot;,&quot;iphone&quot;]], ruleKey = &quot;color&quot;, ruleValue = &quot;silver&quot;输出：1解释：只有一件物品匹配检索规则，这件物品是 [&quot;computer&quot;,&quot;silver&quot;,&quot;lenovo&quot;] 。</code></pre><p><strong>示例 2</strong>：</p><pre><code>输入：items = [[&quot;phone&quot;,&quot;blue&quot;,&quot;pixel&quot;],[&quot;computer&quot;,&quot;silver&quot;,&quot;phone&quot;],[&quot;phone&quot;,&quot;gold&quot;,&quot;iphone&quot;]], ruleKey = &quot;type&quot;, ruleValue = &quot;phone&quot;输出：2解释：只有两件物品匹配检索规则，这两件物品分别是 [&quot;phone&quot;,&quot;blue&quot;,&quot;pixel&quot;] 和 [&quot;phone&quot;,&quot;gold&quot;,&quot;iphone&quot;] 。注意，[&quot;computer&quot;,&quot;silver&quot;,&quot;phone&quot;] 未匹配检索规则。</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= items.length &lt;= 104</code></li><li><code>1 &lt;= typei.length, colori.length, namei.length, ruleValue.length &lt;= 10</code></li><li><code>ruleKey</code> 等于 <code>&quot;type&quot;</code>、<code>&quot;color&quot;</code> 或 <code>&quot;name&quot;</code></li><li>所有字符串仅由小写字母组成</li></ul><h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>题目给出了 <code>ruleKey</code> 仅有三种情况对应 <code>0</code> , <code>1</code> , <code>2</code> 三个下标，然后判断 <code>items</code> 此下标的字符串是否为 <code>ruleValue</code> 即可。</p><h4 id="代码-C"><a href="#代码-C" class="headerlink" title="代码(C++)"></a>代码(C++)</h4><pre><code>class Solution &#123;public:    int countMatches(vector&lt;vector&lt;string&gt;&gt;&amp; items, string ruleKey, string ruleValue) &#123;        int choose;        if(ruleKey == &quot;type&quot;)&#123;choose = 0;&#125;        else if(ruleKey == &quot;color&quot;)&#123;choose = 1;&#125;        else&#123;choose = 2;&#125;                int res = 0;        for(auto i:items)&#123;            if(i[choose] == ruleValue) res++;        &#125;        return res;    &#125;&#125;;</code></pre><h3 id="第二题-最接近目标价格的甜点成本"><a href="#第二题-最接近目标价格的甜点成本" class="headerlink" title="第二题 最接近目标价格的甜点成本"></a>第二题 最接近目标价格的甜点成本</h3><p>你打算做甜点，现在需要购买配料。目前共有 <code>n</code> 种冰激凌基料和 <code>m</code> 种配料可供选购。而制作甜点需要遵循以下几条规则：</p><ul><li>必须选择 <strong>一种</strong> 冰激凌基料。</li><li>可以添加 <strong>一种或多种</strong> 配料，也可以不添加任何配料。</li><li>每种类型的配料 <strong>最多两份</strong> 。</li></ul><p>给你以下三个输入：</p><ul><li><code>baseCosts</code> ，一个长度为 <code>n</code> 的整数数组，其中每个 <code>baseCosts[i]</code> 表示第 <code>i</code> 种冰激凌基料的价格。</li><li><code>toppingCosts</code> ，一个长度为 <code>m</code> 的整数数组，其中每个 <code>toppingCosts[i]</code> 表示 <strong>一份</strong> 第 <code>i</code> 种冰激凌配料的价格。</li><li><code>target</code> ，一个整数，表示你制作甜点的目标价格。</li></ul><p>你希望自己做的甜点总成本尽可能接近目标价格 <code>target</code> 。</p><p>返回最接近 <code>target</code> 的甜点成本。如果有多种方案，返回 <strong>成本相对较低</strong> 的一种。</p><p><strong>示例1</strong>：</p><pre><code>输入：baseCosts = [1,7], toppingCosts = [3,4], target = 10输出：10解释：考虑下面的方案组合（所有下标均从 0 开始）：- 选择 1 号基料：成本 7- 选择 1 份 0 号配料：成本 1 x 3 = 3- 选择 0 份 1 号配料：成本 0 x 4 = 0总成本：7 + 3 + 0 = 10 。</code></pre><p><strong>示例2</strong>：</p><pre><code>输入：baseCosts = [2,3], toppingCosts = [4,5,100], target = 18输出：17解释：考虑下面的方案组合（所有下标均从 0 开始）：- 选择 1 号基料：成本 3- 选择 1 份 0 号配料：成本 1 x 4 = 4- 选择 2 份 1 号配料：成本 2 x 5 = 10- 选择 0 份 2 号配料：成本 0 x 100 = 0总成本：3 + 4 + 10 + 0 = 17 。不存在总成本为 18 的甜点制作方案。</code></pre><p><strong>示例3</strong>：</p><pre><code>输入：baseCosts = [3,10], toppingCosts = [2,5], target = 9输出：8解释：可以制作总成本为 8 和 10 的甜点。返回 8 ，因为这是成本更低的方案。</code></pre><p><strong>示例4</strong>：</p><pre><code>输入：baseCosts = [10], toppingCosts = [1], target = 1输出：10解释：注意，你可以选择不添加任何配料，但你必须选择一种基料。</code></pre><ul><li><code>n == baseCosts.length</code></li><li><code>m == toppingCosts.length</code></li><li><code>1 &lt;= n, m &lt;= 10</code></li><li><code>1 &lt;= baseCosts[i], toppingCosts[i] &lt;= 10000</code></li><li><code>1 &lt;= target &lt;= 10000</code></li></ul><h4 id="思路1"><a href="#思路1" class="headerlink" title="思路1"></a>思路1</h4><p>该题数据量较小 <code>1 &lt;= n, m &lt;= 10</code>，可以直接使用暴力dfs….未完待续，因为我想等一个DP方法，自己没写出来DP</p><h3 id="第三题-通过最少操作次数使数组的和相等"><a href="#第三题-通过最少操作次数使数组的和相等" class="headerlink" title="第三题 通过最少操作次数使数组的和相等"></a>第三题 通过最少操作次数使数组的和相等</h3><p>给你两个长度可能不等的整数数组 <code>nums1</code> 和 <code>nums2</code> 。两个数组中的所有值都在 <code>1</code> 到 <code>6</code> 之间（包含 <code>1</code> 和 <code>6</code>）。</p><p>每次操作中，你可以选择 任意 数组中的任意一个整数，将它变成 <code>1</code> 到 <code>6</code> 之间 任意 的值（包含 <code>1</code> 和 <code>6</code>）。</p><p>请你返回使 <code>nums1</code> 中所有数的和与 <code>nums2</code> 中所有数的和相等的最少操作次数。如果无法使两个数组的和相等，请返回 <code>-1</code> 。</p><p> </p><p><strong>示例 1</strong>：</p><pre><code>输入：nums1 = [1,2,3,4,5,6], nums2 = [1,1,2,2,2,2]输出：3解释：你可以通过 3 次操作使 nums1 中所有数的和与 nums2 中所有数的和相等。以下数组下标都从 0 开始。- 将 nums2[0] 变为 6 。 nums1 = [1,2,3,4,5,6], nums2 = [6,1,2,2,2,2] 。- 将 nums1[5] 变为 1 。 nums1 = [1,2,3,4,5,1], nums2 = [6,1,2,2,2,2] 。- 将 nums1[2] 变为 2 。 nums1 = [1,2,2,4,5,1], nums2 = [6,1,2,2,2,2] 。</code></pre><p><strong>示例 2</strong>：</p><pre><code>输入：nums1 = [1,1,1,1,1,1,1], nums2 = [6]输出：-1解释：没有办法减少 nums1 的和或者增加 nums2 的和使二者相等。</code></pre><p><strong>示例 3</strong>：</p><pre><code>输入：nums1 = [6,6], nums2 = [1]输出：3解释：你可以通过 3 次操作使 nums1 中所有数的和与 nums2 中所有数的和相等。以下数组下标都从 0 开始。- 将 nums1[0] 变为 2 。 nums1 = [2,6], nums2 = [1] 。- 将 nums1[1] 变为 2 。 nums1 = [2,2], nums2 = [1] 。- 将 nums2[0] 变为 4 。 nums1 = [2,2], nums2 = [4] 。</code></pre><p> </p><p><strong>提示</strong>：</p><pre><code>1 &lt;= nums1.length, nums2.length &lt;= 1000001 &lt;= nums1[i], nums2[i] &lt;= 6</code></pre><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><ol><li><p>由示例2我们得知，如果有一方的长度 * 6 仍小于另一方，我们可以肯定无法使两个数组的和相等。</p></li><li><p>先计算两个数组各自的和，如果和相等，就不用改变数组，就直接 <code>return 0;</code>。</p></li><li><p>贪心的思路，因为可以在 <code>1</code> 到 <code>6</code> 中任意改变，所以我们可以把所有元素改变最大的记录下来。</p></li><li><p>继以上观点，我们可以以 <code>nums1</code> 为参照物，做增加和减少两个数组 <code>inc</code>、<code>dec</code>，<code>nums</code> 可以增加的部分就相当于 <code>nums1</code> 减少的部分。遍历两个数组得到以 <code>nums1</code> 为参照物的两个最多可以增加或者减少的数组。</p></li><li><p>从大往小去改变两个数组和的差值，直到两个数的大小关系颠倒就说明可以使两个数相等。（因为可以在 <code>1</code> 到 <code>6</code> 中任意改变），每次改变增加记录的值。</p></li><li><p>最后如果发现无法得到结果就返回 <code>-1</code>。</p></li></ol><h4 id="代码-C-1"><a href="#代码-C-1" class="headerlink" title="代码(C++)"></a>代码(C++)</h4><pre><code>class Solution &#123;public:    int minOperations(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123;        int len1 = nums1.size(), len2 = nums2.size();        if(len1 * 6 &lt; len2 || len2 * 6 &lt; len1) return -1;        int sum1 = 0, sum2 = 0;        vector&lt;int&gt; inc(6);        vector&lt;int&gt; dec(6);        for(auto num: nums1)&#123;            sum1 += num;            inc[6-num]++;            dec[num-1]++;        &#125;        for(auto num: nums2)&#123;            sum2 += num;            dec[6-num]++;            inc[num-1]++;        &#125;        int res = 0;        if(sum1 == sum2) return 0;        if(sum1 &gt; sum2)&#123;            for(int i=5;i&gt;=1;i--)&#123;                while(dec[i])&#123;                    sum1 -= i;                    dec[i] --;                    res ++;                    if(sum1 &lt;= sum2) return res;                &#125;            &#125;        &#125;else&#123;            for(int i=5;i&gt;=1;i--)&#123;                while(inc[i])&#123;                    sum1 += i;                    inc[i] --;                    res ++;                    if(sum1 &gt;= sum2) return res;                &#125;            &#125;        &#125;        return -1;    &#125;&#125;;</code></pre><h3 id="第四题-车队-II"><a href="#第四题-车队-II" class="headerlink" title="第四题 车队 II"></a>第四题 车队 II</h3><p>在一条单车道上有 <code>n</code> 辆车，它们朝着同样的方向行驶。给你一个长度为 <code>n</code> 的数组 <code>cars</code> ，其中 <code>cars[i] = [positioni, speedi]</code> ，它表示：</p><ul><li><code>positioni</code> 是第 <code>i</code> 辆车和道路起点之间的距离（单位：米）。题目保证 <code>positioni &lt; positioni+1</code> 。</li><li><code>speedi</code> 是第 <code>i</code> 辆车的初始速度（单位：米/秒）。<br>简单起见，所有车子可以视为在数轴上移动的点。当两辆车占据同一个位置时，我们称它们相遇了。一旦两辆车相遇，它们会合并成一个车队，这个车队里的车有着同样的位置和相同的速度，速度为这个车队里 最慢 一辆车的速度。</li></ul><p>请你返回一个数组 <code>answer</code> ，其中 <code>answer[i]</code> 是第 <code>i</code> 辆车与下一辆车相遇的时间（单位：秒），如果这辆车不会与下一辆车相遇，则 <code>answer[i]</code> 为 <code>-1</code> 。答案精度误差需在 <code>10e-5</code> 以内。</p><p> </p><p><strong>示例 1</strong>：</p><pre><code>输入：cars = [[1,2],[2,1],[4,3],[7,2]]输出：[1.00000,-1.00000,3.00000,-1.00000]解释：经过恰好 1 秒以后，第一辆车会与第二辆车相遇，并形成一个 1 m/s 的车队。经过恰好 3 秒以后，第三辆车会与第四辆车相遇，并形成一个 2 m/s 的车队。</code></pre><p><strong>示例 2</strong>：</p><pre><code>输入：cars = [[3,4],[5,4],[6,3],[9,1]]输出：[2.00000,1.00000,1.50000,-1.00000]</code></pre><p> </p><p><strong>提示</strong>：</p><pre><code>1 &lt;= cars.length &lt;= 10e51 &lt;= positioni, speedi &lt;= 10e6positioni &lt; positioni+1</code></pre><p>不会有人真以为我写出最后一题了吧，就先未完待遇，等我学会了就写解析。。。。。。</p>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
      <category>周赛</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>接口与多态(上)</title>
    <link href="/2021/02/27/%E6%8E%A5%E5%8F%A3%E4%B8%8E%E5%A4%9A%E6%80%81-%E4%B8%8A/"/>
    <url>/2021/02/27/%E6%8E%A5%E5%8F%A3%E4%B8%8E%E5%A4%9A%E6%80%81-%E4%B8%8A/</url>
    
    <content type="html"><![CDATA[<h2 id="接口与多态-上"><a href="#接口与多态-上" class="headerlink" title="接口与多态(上)"></a>接口与多态(上)</h2><span id="more"></span><h3 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h3><p>接口和多态的关系是千丝万缕的，多态是Java三大特性之一，而接口是最能体现多态的，接口和实现类的关系，以及各个实现类之间的关系，不像父类和子类之间，子类和其他子类之间的要求那么严格。</p><p>举个例子,拿”吃饭”这个 <code>method</code> 举例…如果把这个 <code>method</code> 声明在父类中,那么子类必须要和父类是”同类”，父类是人，那么”吃饭”这个功能就被限制死了，只能被人来完成…</p><p>如果把这个功能声明在”接口”中，那么完成这个功能的不光能是人，可以狗，可以是猫，可以是任何东西,只要它能”吃饭”…这个就最大限度地体现了”多种形态”…</p><p>接口的多态性，就体现在只关心”你能做什么”，而不关心”你是谁”…</p><h3 id="详细的讲一下多态"><a href="#详细的讲一下多态" class="headerlink" title="详细的讲一下多态"></a>详细的讲一下多态</h3><p>多态存在有三个前提：</p><ol><li><p>继承关系</p></li><li><p>子类要重写父类的方法</p></li><li><p>父类引用指向子类对象</p></li></ol><p>我们先上代码</p><pre><code>public class Employee &#123;    int age = 25;    static int salary = 1000;    public void work()&#123;        System.out.println(&quot;打工人工作&quot;);    &#125;    public void eat()&#123;        System.out.println(&quot;打工人吃饭&quot;);    &#125;    public static void resign()&#123;        System.out.println(&quot;打工人跑路&quot;);    &#125;&#125;public class Manager extends Employee&#123;    static int salary = 10000;    int age = 30;    @Override    public void work() &#123;        System.out.println(&quot;经理工作&quot;);    &#125;    public static void resign() &#123;        System.out.println(&quot;经理跳槽&quot;);    &#125;    public void bonuses()&#123;        System.out.println(&quot;经理领奖金&quot;);    &#125;&#125;</code></pre><p>显然经理也是打工人，所以经理以打工人为超类。但是打工人中 <code>跑路</code> 是用 <code>static</code> 标识的，说明它不可继承。(普通打工人才跑路，经理只有跳槽)</p><pre><code>public static void main(String[] args) &#123;    Employee a = new Manager();    a.work();    a.resign();    a.eat();//  a.bonuses();//报错，不能调用这个方法    System.out.println(a.age);    System.out.println(a.salary);&#125;</code></pre><p>运行结果如下</p><pre><code>经理工作打工人跑路打工人吃饭251000</code></pre><p>我们用多态的三个前提验证一下</p><ol><li><p><code>Manager</code> 继承了 <code>Employee</code> 类。</p></li><li><p><code>Manager</code> 类重写了 <code>eat</code> 方法。</p></li><li><p>父类数据类型的引用指向了子对象， <code>Employee a = new Manager();</code>。</p></li></ol><p>为什么会出现经理变成了打工人的情况？</p><p>这其实就是多态成员访问的特点：</p><p><strong>成员变量</strong><br>编译看左边(超类)，运行看左边(超类)。</p><p><strong>成员方法</strong></p><p>编译看左边(超类)，运行看右边(子类)。</p><p><strong>静态方法</strong></p><p>编译看左边(超类)，运行看左边(超类)。(静态只与类绑定，和其他一切无关，所以不能被继承)</p><hr><p>这其实也算是多态的一种弊端，即<strong>多态后不能使用子类特有的属性与方法</strong>。</p><p>如果霸王硬上弓，强行转换这个类的属性呢。</p><pre><code>public static void main(String[] args) &#123;    Employee a = new Manager();    Manager b = (Manager) a;    b.bonuses();    b.work();    b.eat();    System.out.println(b.age);    System.out.println(b.salary);&#125;</code></pre><p>结果是</p><pre><code>经理领奖金经理工作打工人吃饭3010000</code></pre><p>我们发现硬上弓之后它就从了，b就指向Manager类型了。但是，它仍能使用父类的方法，十分灵活。但我们为什么不一开始就 <code>Manager b = new Manager();</code> 呢。实际上多态就是这样十分灵活的，他可以先以多态形式，如果我们需要强行转换也不是不可以，减少了多余类的创建，也是不错的。</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://www.zhihu.com/question/30082151/answer/120520568">JAVA的多态用几句话能直观的解释一下吗？</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span>Java核心技术 卷一 P162<a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
      <category>Java</category>
      
      <category>Java基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编程语言的运用</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode395.至少有K个重复字符的最长子串</title>
    <link href="/2021/02/27/leetcode395-%E8%87%B3%E5%B0%91%E6%9C%89K%E4%B8%AA%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/"/>
    <url>/2021/02/27/leetcode395-%E8%87%B3%E5%B0%91%E6%9C%89K%E4%B8%AA%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/</url>
    
    <content type="html"><![CDATA[<h2 id="leetcode395-至少有K个重复字符的最长子串"><a href="#leetcode395-至少有K个重复字符的最长子串" class="headerlink" title="leetcode395.至少有K个重复字符的最长子串"></a>leetcode395.至少有K个重复字符的最长子串</h2><span id="more"></span><p><a href="https://leetcode-cn.com/problems/longest-substring-with-at-least-k-repeating-characters/">刷题入口</a></p><p>给你一个字符串 <code>s</code> 和一个整数 <code>k</code> ，请你找出 <code>s</code> 中的最长子串， 要求该子串中的每一字符出现次数都不少于 <code>k</code> 。返回这一子串的长度。</p><p><strong>示例1：</strong></p><pre><code>输入：s = &quot;aaabb&quot;, k = 3输出：3解释：最长子串为 &quot;aaa&quot; ，其中 &#39;a&#39; 重复了 3 次。</code></pre><p><strong>示例2：</strong></p><pre><code>输入：s = &quot;ababbc&quot;, k = 2输出：5解释：最长子串为 &quot;ababb&quot; ，其中 &#39;a&#39; 重复了 2 次， &#39;b&#39; 重复了 3 次。</code></pre><p>提示：</p><ul><li><code>1 &lt;= s.length &lt;= 104</code></li><li><code>s</code> 仅由小写英文字母组成</li><li>1 &lt;= k &lt;= 10<sup>5</sup></li></ul><p>首先，我们看看负雪明烛大佬的递归方法。<a href="https://leetcode-cn.com/problems/longest-substring-with-at-least-k-repeating-characters/solution/jie-ben-ti-bang-zhu-da-jia-li-jie-di-gui-obla/">原题解地址</a></p><h3 id="1-递归"><a href="#1-递归" class="headerlink" title="1.递归"></a>1.递归</h3><p>递归看着就挺让人头疼的，但实际用起来还挺好用的。递归的重点就在于把递归函数当成一个普通的函数调用，只管它的输入和输出，不用细想里面的过程会好很多。如果还是头疼，可以吃几片止疼药。</p><p><strong>详细题解：</strong></p><ol><li><p><strong>递归最基本的是记住递归函数的含义（务必牢记函数定义）</strong>：本题的 <code>longestSubstring(s, k)</code> 函数表示的就是题意，即求一个最长的子字符串的长度，该子字符串中每个字符出现的次数都最少为 <code>k</code> 。函数入参 <code>s</code> 是表示源字符串； <code>k</code> 是限制条件，即子字符串中每个字符最少出现的次数；函数返回结果是满足题意的最长子字符串长度。</p></li><li><p><strong>递归的终止条件（能直接写出的最简单 <code>case</code> ）</strong>：如果字符串 <code>s</code> 的长度少于 <code>k</code> ，那么一定不存在满足题意的子字符串，返回 <code>0</code>；</p></li><li><p><strong>调用递归（重点）</strong>：如果一个字符 <code>c</code> 在 <code>s</code> 中出现的次数少于 <code>k</code> 次，那么 <code>s</code> 中所有的包含 <code>c</code> 的子字符串都不能满足题意。所以，应该在 <code>s</code> 的所有不包含 <code>c</code> 的子字符串中继续寻找结果：把 <code>s</code> 按照 <code>c</code> 分割（分割后每个子串都不包含 <code>c</code>），得到很多子字符串 <code>t</code>；下一步要求 <code>t</code> 作为源字符串的时候，它的最长的满足题意的子字符串长度（到现在为止，我们把大问题分割为了小问题<code>(s → t)</code>）。此时我们发现，恰好已经定义了函数 <code>longestSubstring(s, k)</code> 就是来解决这个问题的！所以直接把 <code>longestSubstring(s, k)</code> 函数拿来用，于是形成了递归。</p></li><li><p><strong>未进入递归时的返回结果</strong>：如果 <code>s</code> 中的每个字符出现的次数都大于 <code>k</code> 次，那么 <code>s</code> 就是我们要求的字符串，直接返回该字符串的长度。</p></li></ol><p>递归函数是怎么一层一层展开我们不要用自己的脑袋想，交给计算机就完事。</p><p><strong>代码：</strong></p><pre><code>class Solution &#123;    public int longestSubstring(String s, int k) &#123;        if (s.length() &lt; k) return 0;        HashMap&lt;Character, Integer&gt; counter = new HashMap();        for (int i = 0; i &lt; s.length(); i++) &#123;            counter.put(s.charAt(i), counter.getOrDefault(s.charAt(i), 0) + 1);        &#125;        for (char c : counter.keySet()) &#123;            if (counter.get(c) &lt; k) &#123;                int res = 0;                for (String t : s.split(String.valueOf(c))) &#123;                    res = Math.max(res, longestSubstring(t, k));                &#125;                return res;            &#125;        &#125;        return s.length();    &#125;&#125;</code></pre><p>由于是递归，时间复杂度高是必然的。</p><p><strong>结果：</strong></p><p><img src="/img/leetcode/395o.jpg" alt="result1"></p><p>而递归就是把分治法更清晰的展示出来，本质上还是用了分治的方法。</p>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
      <category>分治</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>递归</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一切皆对象:Object类的11个方法(上)</title>
    <link href="/2021/02/25/%E4%B8%80%E5%88%87%E7%9A%86%E5%AF%B9%E8%B1%A1-Object%E7%B1%BB%E7%9A%8411%E4%B8%AA%E6%96%B9%E6%B3%95(%E4%B8%8A)/"/>
    <url>/2021/02/25/%E4%B8%80%E5%88%87%E7%9A%86%E5%AF%B9%E8%B1%A1-Object%E7%B1%BB%E7%9A%8411%E4%B8%AA%E6%96%B9%E6%B3%95(%E4%B8%8A)/</url>
    
    <content type="html"><![CDATA[<h2 id="一切皆对象-Object类的11个方法-上"><a href="#一切皆对象-Object类的11个方法-上" class="headerlink" title="一切皆对象:Object类的11个方法(上)"></a>一切皆对象:Object类的11个方法(上)</h2><span id="more"></span><h3 id="重要性"><a href="#重要性" class="headerlink" title="重要性"></a>重要性</h3><p>Object类是一切Java中一切类默认的超类，是包括自建类的所有类继承的一个很重要的类。所有类都可以调用其中的11种方法，这十一种方法具有十分的通用性与易用性，要求每一个都熟练理解并掌握。</p><h3 id="1-toString"><a href="#1-toString" class="headerlink" title="1. toString()"></a>1. toString()</h3><p>正如 <code>toString</code> 的名字， <code>toString()</code> 就是将一个对象转换为字符串然后输出。</p><p>让我们来到手撕源码环节</p><pre><code>public String toString() &#123;    return getClass().getName() + &quot;@&quot; + Integer.toHexString(hashCode());&#125;</code></pre><p>一脸蒙蔽，追查源码同样一脸蒙蔽，基本追查不下去，那我们开始实操环节，用我们最经典的 <code>Employee</code> 类做实验。</p><pre><code>public class Employee &#123;    private String name;    private double salary;    private LocalDate hireDay;    public Employee(String n, double s, int year, int month, int day)    &#123;        name = n;        salary = s;        hireDay = LocalDate.of(year, month, day);    &#125;    public static void main(String[] args) &#123;        Employee e = new Employee(&quot;abc&quot;, 1, 2000, 1, 1);        System.out.println(e.toString());        Integer i = new Integer(&quot;123&quot;);//我们再拿Integer做实验        System.out.println(i);        System.out.println(i.toString());        System.out.println(i.toString().getClass());//getClass()类同样是Object中的一个方法，作用是返回类名，我们在下面详细的介绍。    &#125;&#125;</code></pre><p>结果是</p><pre><code>inheritance.Employee@16d3586123123class java.lang.String</code></pre><p>我们发现，<code>i.toString()</code> 并没有基类所带的 <code>@</code> ，说明它可能放弃了基类的教导，转身重写了 <code>toString()</code>，我们追查一下。</p><pre><code>public String toString() &#123;    return toString(value);&#125;public static String toString(int i) &#123;    if (i == Integer.MIN_VALUE)        return &quot;-2147483648&quot;;    int size = (i &lt; 0) ? stringSize(-i) + 1 : stringSize(i);    char[] buf = new char[size];    getChars(i, size, buf);    return new String(buf, true);&#125;</code></pre><p>果然不错，凡是我们知道能用串表示出来的，经过追查，都忘了初心，变成了我们更好用的样子，即直接转换为字符串。只有那些不能用串表示的，才会接过 <code>Object</code> 的摊子。而我们此刻应该去和那些忘了初心的类学习，重写 <code>toString</code>。就以打工人这个类为例。</p><pre><code>@Override//表示对父类方法的重写public String toString() &#123;    return &quot;Employee&#123;&quot; +            &quot;name=&#39;&quot; + name + &#39;\&#39;&#39; +            &quot;, salary=&quot; + salary +            &quot;, hireDay=&quot; + hireDay +            &#39;&#125;&#39;;&#125;</code></pre><p>我们 <code>System.out.println(e.toString());</code> 的结果如下</p><pre><code>Employee&#123;name=&#39;abc&#39;, salary=1.0, hireDay=2000-01-01&#125;//我这才发现这个苦逼打工人的薪水只有一块钱</code></pre><p>果然重写之后的 <code>toString</code> 更加适合我们去用。</p><p><font size=3>这其实也奠定了一个基调，部分时候 <code>Object</code> 的方法要重写成适合使用的模样。</font></p><h3 id="2-equals"><a href="#2-equals" class="headerlink" title="2. equals()"></a>2. equals()</h3><p> <code>equals</code> 方法用于检测一个对象是否等于另一个对象，这是一个合理的默认行为：如果两个对象的引用相等，这两个对象肯定就相等。如果基于状态检测对象的相等于，两个对象有相同的状态，才认为这两个对象是相等的。</p><p> 话不多说，我们上一段代码:</p><pre><code>public class Person&#123;    private String name;    public Person(String name)&#123;this.name = name;&#125;&#125;public static void main(String[] args)&#123;    String s3 = new String(&quot;100&quot;);    String s4 = new String(&quot;100&quot;);    System.out.println(s3.equals(s4));    Integer itr = new Integer(&quot;123&quot;);    Long lon = new Long(&quot;123&quot;);    System.out.println(itr.equals(lon));    Person person1 = new Person(&quot;张三&quot;);    Person person2 = new Person(&quot;张三&quot;);    System.out.println(person1.equals(person2));&#125;</code></pre><p>结果是 <code>true false false</code></p><p>我们要想知道为什么是这个结果，首先就要研究一下 <code>equals()</code> 的源码</p><pre><code>public boolean equals(Object obj)&#123;    return(this == obj);&#125;</code></pre><p>很简单，就是判断两个引用是否指向同一个对象，由于 <code>Person</code> 类并没有重写 <code>equals</code> ，所以继承的就是 <code>Object</code> 中的<code>equals()</code> ，在内存的观点来看，两个 <code>Person</code> 对象显然是不同的。</p><p><img src="/img/Java/Object/equals1.jpg" alt="在内存中的示意图"></p><p>在 <code>Integer</code> 中，<code>equals</code> 的实现如下</p><pre><code>public boolean equals(Object obj)&#123;    if(obj instanceof Integer)&#123;        return value == ((Integer)obj).intValue();    &#125;    return false;&#125;</code></pre><p>意思很明确，判断对象类型是否可以为 <code>Integer</code> (参考我的上一篇: 类与继承)，这里 <code>lon</code> 是 <code>Long</code> 类型，所有结果肯定是 <code>false</code> 。</p><p>最后我们看看 <code>String</code> 的实现</p><pre><code>public boolean equals(Object anObject) &#123;    if (this == anObject) &#123;        return true;    &#125;    if (anObject instanceof String) &#123;        String anotherString = (String)anObject;        int n = value.length;        if (n == anotherString.value.length) &#123;            char v1[] = value;            char v2[] = anotherString.value;            int i = 0;            while (n-- != 0) &#123;                if (v1[i] != v2[i])                    return false;                i++;            &#125;            return true;        &#125;    &#125;    return false;&#125;</code></pre><p>如果都指向一个引用，毋庸置疑是相等的。接下来有三个步骤</p><ol><li>判断是否为String类型。</li><li>判断这两个字符串底层char数组的长度是否一致。</li><li>循环判断每一个char字符是否相等。</li></ol><p>我们的s3，s4显然不满足第一步，但可以过了下面三关，成功打印出 <code>true</code> 。</p><p>显然，我们超类 <code>Object</code> 的 <code>equals()</code> 只是判断二者引用是否相同，大部分时候，还是需要我们重写 <code>equals()</code> 来定义是否相等。</p><p><font size=3>由此，我们能回答一个面试的经典问题： <code>==</code> 和 <code>equals()</code> 有什么区别？</font></p><p> <code>==</code> 指的就是引用相同，和超类中的 <code>equals</code> 意义相同，而大部分情况，我们需要重写 <code>equals</code> 来定义两个对象是否相同，这时候含义就与 <code>==</code> 不同了。</p><h3 id="3-hashCode"><a href="#3-hashCode" class="headerlink" title="3. hashCode()"></a>3. hashCode()</h3><p> <code>hashCode</code> 方法是由对象导出的一个整形值。散列码没有规律，如果 <code>x</code> 和 <code>y</code> 是两个不同的对象，那么 <code>x.hashCode()</code> 和 <code>y.hashCode()</code> 基本上不会相同。简单的来说，<code>hashCode</code>就像是一个签名，当两个对象的 <code>hashcode</code> 一样，那么两个对象就可能一样，如果不一样，那两个对象肯定不是同一个对象。等于 <code>hashcode</code> 可以确定一个大范围，然后可以使用 <code>equals</code> 来比较。</p><p>即 <code>对象1</code> 和 <code>对象2</code> 签名(散列码) 相等并不能确定两个对象相等，凡是如果两个对象相等，它们的散列码一定是相等的。</p><p>所以 <code>hashcode</code> 可以减少 <code>equals</code> 比较的次数，提高运算效率。</p><p>我们来看一下没有重写的 <code>hashCode</code> 在实战中的表现</p><pre><code>    Employee e = new Employee(&quot;abc&quot;, 1, 2000, 1, 1);    Employee d = new Employee(&quot;abc&quot;, 1, 2000, 1, 1);    System.out.println(e.hashCode()== d.hashCode());</code></pre><p>结果是 <code>false</code> 。在 <code>equals</code> 中，我们也试验了，<code>e</code> 是不等于 <code>d</code> 的，如果先用 <code>hashCode</code> 检测，就能更有效率的发现二者不相等了。所以我们一般用 <code>hashcode</code> 来进行比较两个东西是不是一样的，可以很容易的排除许多不一样的东西。</p><p> <code>hashCode</code> 在官方源码的文档可以提取处几个要点：</p><ol><li><p><code>hashCode</code> 的存在主要是用于查找的快捷性，如 <code>Hashtable</code> ，<code>HashMap</code>等，<code>hashCode</code>是用来在散列存储结构中确定对象的存储地址的；</p></li><li><p>如果两个对象相同，就是适用于 <code>equals(Java.lang.Object)</code> 方法，那么这两个对象的 <code>hashCode</code> 一定要相同</p></li><li><p>如果对象的 <code>equals</code> 方法被重写，那么对象的 <code>hashCode</code> 也尽量重写，并且产生 <code>hashCode</code> 使用的对象，一定要和 <code>equals</code> 方法中使用的一致，否则就会违反上面提到的第2点</p></li><li><p>两个对象的 <code>hashCode</code> 相同，并不一定表示两个对象就相同，也就是不一定适用于 <code>equals(java.lang.Object)</code> 方法，只能够说明这两个对象在散列存储结构中，如 <code>Hashtable</code> ，他们“存放在同一个篮子里”。</p></li></ol><p>但我们经过上面两轮发现，<code>Object</code> 中的方法大部分是需要重写的，而 <code>hashCode</code> 在实际应用中非常重要，是需要重写的重中之重，下面我们还是用打工人这个类，重写一下 <code>hashCode</code> 方法。</p><pre><code>@Overridepublic int hashCode() &#123;    return Objects.hash(getName(), getSalary(), hireDay);&#125;@Overridepublic boolean equals(Object o) &#123;    if (this == o) return true;    if (!(o instanceof Employee)) return false;    Employee employee = (Employee) o;    return Double.compare(employee.getSalary(), getSalary()) == 0 &amp;&amp; Objects.equals(getName(), employee.getName()) &amp;&amp; Objects.equals(hireDay, employee.hireDay);&#125;public static void main(String[] args) &#123;    Employee e = new Employee(&quot;abc&quot;, 1, 2000, 1, 1);    Employee d = new Employee(&quot;abc&quot;, 1, 2000, 1, 1);    System.out.println(e.hashCode()== d.hashCode());    System.out.println(e.equals(d));</code></pre><p>结果是:</p><pre><code>truetrue</code></pre><p>和上面没有重写的结果显然就不一样了，实际上这两个对象除了地址不一样，别的不能说几分相像，简直是一模一样。</p><p>但是我们实际情况中肯定更复杂，一个打工人的属性肯定也不会只有这些，一般是按照 <code>id</code> 来确认 <code>hashcode</code> 再确认是否相等的。</p><p>PS: 在覆写 <code>equals()</code> 方法的时候也必须覆写 <code>hashCode()</code> 方法。这样才能确保相等的两个对象拥有相等的 <code>.hashCode</code>。</p><p>再使用 <code>IDEA</code> 进行编程时，如果你需要重写一般会为你生成一个较好的方案，但仍要实际情况实际分析，选择效率与准确性最高的方法。</p><h3 id="4-clone"><a href="#4-clone" class="headerlink" title="4. clone()"></a>4. clone()</h3><p>提到 <code>clone</code> ，显而易见，就是复制一个对象，正如 <code>C++</code> 一样，复制同样分为深复制与浅复制。</p><p>浅复制指被复制对象的所有数据成员都含有与原来对象相同的值，包括引用类型的数据成员，即不复制引用类型数据成员所指向的对象。深复制实现的是数据成员的全面复制，包括复制产生引用成员所指向的对象的副本。</p><p>接下来通过几个实例来分析</p><p>实例1</p><pre><code>public static void main(String[] args) &#123;    Employee a = new Employee(&quot;abc&quot;, 1, 2000, 1, 1);    Employee b = a;    System.out.println(a);    System.out.println(b);&#125;</code></pre><p>结果是</p><pre><code>inheritance.Employee@c3d3dc82inheritance.Employee@c3d3dc82</code></pre><p>其实我们这儿就可以发现，直接打印一个对象就是打印它 <code>toString()</code> 的值，如果重写了，就打印重写的值。这两个指向的地址显然一模一样，就是复制了引用。实际上，这就是<strong>浅复制</strong>。</p><p>从JVM的角度来看</p><p><img src="/img/Java/Object/JVM1.jpg" alt="不要在意为什么是dog"></p><p>实例2</p><pre><code>public static void main(String[] args) throws CloneNotSupportedException &#123;//抛出异常    Employee a = new Employee(&quot;abc&quot;, 1, 2000, 1, 1);    Employee b = (Employee) a.clone();    System.out.println(a);    System.out.println(b);&#125;</code></pre><p>运行，我们发现，就算我们抛出了异常，依然出错。我们就该知道，<code>clone</code> 这个方法不简单, 下面我们来介绍如何用他进行复制。</p><p> <code>Object</code> 的 <code>clone()</code> 方法，实现了对象中各个属性的复制，但它的可见范围是 <code>protected</code> 的，所以实体类使用克隆的前提是：</p><ol><li>实现Cloneable接口，这是一个标记接口，自身没有方法。 </li><li>覆盖clone()方法，可见性提升为public。</li></ol><p>让我们实现一下</p><pre><code>public class Employee implements Cloneable &#123;    private String name;    private double salary;    private LocalDate hireDay;    @Override    protected Object clone() throws CloneNotSupportedException&#123;        return super.clone();    &#125;    public Employee(String n, double s, int year, int month, int day)    &#123;        name = n;        salary = s;        hireDay = LocalDate.of(year, month, day);    &#125;    public static void main(String[] args) throws CloneNotSupportedException &#123;        Employee a = new Employee(&quot;abc&quot;, 1, 2000, 1, 1);        Employee b = (Employee) a.clone();        System.out.println(a==b);    &#125;&#125;</code></pre><p><code>implements Cloneable</code> 即表示这个类是可以复制的，这时候才能对其对象进行复制。</p><p>运行的结果是 <code>false</code>, 即 <code>OBject</code> 的 <code>clone</code>，并不能把他俩拽到同一个引用，从JVM上看</p><p><img src="/img/Java/Object/JVM2.jpg" alt="因为是打工狗"></p><p>其实这就是<strong>深复制</strong>，创建了新的一个对象而不是简单的引用。发现这两个对象也是两个地址的。</p><p><font size=3>大部分情况，我们还是要用深复制，且要根据实际情况考虑是否重写方法</font></p><h3 id="5-finalize"><a href="#5-finalize" class="headerlink" title="5. finalize()"></a>5. finalize()</h3><p><code>Java9</code> 开始，<code>finalize()</code> 在源码上被标注上了 <code>@Deprecated</code> , 代表这finalize的正式退休。</p><p> <code>finalize</code> 方法原本作用就是处理系统资源、执行其他清理或者对象自救，实际上，<code>Object</code> 中的 <code>finalize</code> 只是建议回收资源，并没有正式析构，大部分时候对对象回收还是要重写 <code>finalize</code> 的。</p><p>既然已经退休了，我们就不再学习它了，等到资源回收专题会讲解更适用的方法。</p><h3 id="6-getClass"><a href="#6-getClass" class="headerlink" title="6. getClass()"></a>6. getClass()</h3><p> <code>getClass</code> 方法将返回一个对象所属的类，顾名思义，也就是返回对象的类的名称。</p><p>就比如我们的打工人类，我们再次拿来做示范 </p><pre><code>Employee a = new Employee(&quot;abc&quot;, 1, 2000, 1, 1);System.out.println(a.getClass());</code></pre><p>结果是</p><pre><code>class inheritance.Employee</code></pre><p>很简单，就是返回类名。 <code>getClass()</code> 的实际作用就是获得这个类，进而通过这个类来获取与之相关的信息。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这个是上篇，下篇的方法大多和多线程关系巨大，还比较高级，先掌握好基础，多练习这些方法，在做项目时根据项目的实际情况来重写相对应的方法。</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>[^1] <a href="https://zhuanlan.zhihu.com/p/27573287">说说Java里的equals（上）</a><br>[^2] <a href="https://zhuanlan.zhihu.com/p/26814793">Java中的HashCode</a><br>[^3] <a href="https://blog.csdn.net/qq_33314107/article/details/80271963">java对象clone()方法</a></p>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
      <category>Java</category>
      
      <category>Java基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编程语言的运用</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>动态规划:最经典LIS单串问题</title>
    <link href="/2021/02/25/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E6%9C%80%E7%BB%8F%E5%85%B8LIS%E5%8D%95%E4%B8%B2%E9%97%AE%E9%A2%98/"/>
    <url>/2021/02/25/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E6%9C%80%E7%BB%8F%E5%85%B8LIS%E5%8D%95%E4%B8%B2%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h2 id="动态规划-最经典LIS单串问题"><a href="#动态规划-最经典LIS单串问题" class="headerlink" title="动态规划:最经典LIS单串问题"></a>动态规划:最经典LIS单串问题</h2><span id="more"></span><h3 id="1-最长上升子序列"><a href="#1-最长上升子序列" class="headerlink" title="1. 最长上升子序列"></a>1. 最长上升子序列</h3><p><a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/">出处:leetcode300</a></p><p>给你一个整数数组 <code>nums</code> ，找到其中最长严格递增子序列的长度。</p><p>子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，<code>[3,6,2,7]</code> 是数组 <code>[0,3,1,6,2,2,7]</code> 的子序列。</p><p><strong>示例 1：</strong></p><pre><code>输入：nums = [10,9,2,5,3,7,101,18]输出：4解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：nums = [7,7,7,7,7,7,7]输出：1</code></pre><ul><li><code>1 &lt;= nums.length &lt;= 2500</code></li><li><code>-104 &lt;= nums[i] &lt;= 104</code></li></ul><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>首先我们知道每个数字本身就是一个一位的上升序列，所以长度至少为一。之后我们来找枚举处一些规律，用 <code>i</code> 表示当前位(0开始), <code>dp[]</code> 为到第 <code>i</code> 位(包括)的最长上升子序列: </p><ul><li><code>i=0</code> ，显然最长为1</li><li><code>i=1</code> ，如果 <code>nums[1]&gt;nums[0]</code> ,那么为 <code>dp[1]=2</code> ，否则为仍为1</li><li><code>i=2</code> ，先看与 <code>nums[0]</code> 大小，如果小于 <code>num[0]</code> 则 <code>dp[2]=dp[0]+1</code> ，否则再看与 <code>nums[1]</code> 的大小，如果比 <code>nums[1]</code> 大，那就是 <code>dp[1]+1和dp[0]+1</code> 的最大值。</li></ul><p><font size=4>我们可以推出这个结论，如果 <code>i=n，nums[i]&gt;nums[j](j&lt;i)</code> ，那么i=n时的最长子序列就是 <code>max(dp[i], dp[j]+1)</code> </font></p><p>由此我们容易写出代码:</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><pre><code>class Solution &#123;    public int lengthOfLIS(int[] nums) &#123;        int len = nums.length;        int []dp = new int [len];        for(int i=0;i&lt;len;i++)&#123;            dp[i] = 1;        &#125;        for(int i=1;i&lt;len;i++)&#123;            for(int j=0;j&lt;i;j++)&#123;                if(nums[i]&gt;nums[j])&#123;                    dp[i] = Math.max(dp[i], dp[j]+1);                &#125;            &#125;        &#125;                int max = dp[0];        for(int i:dp)&#123;            if(i&gt;max)&#123;max = i;&#125;        &#125;        return max;    &#125;&#125;</code></pre><p><img src="/img/leetcode/result.png" alt="result1"></p><p>下面我们看一下经典题的改版: </p><hr><h3 id="2-俄罗斯套娃信封问题"><a href="#2-俄罗斯套娃信封问题" class="headerlink" title="2. 俄罗斯套娃信封问题"></a>2. 俄罗斯套娃信封问题</h3><p><a href="https://leetcode-cn.com/problems/russian-doll-envelopes/">出处:leetcode354</a></p><p>给定一些标记了宽度和高度的信封，宽度和高度以整数对形式 <code>(w, h)</code> 出现。当另一个信封的宽度和高度都比这个信封大的时候，这个信封就可以放进另一个信封里，如同俄罗斯套娃一样。</p><p>请计算最多能有多少个信封能组成一组“俄罗斯套娃”信封（即可以把一个信封放到另一个信封里面）。</p><p><strong>说明:</strong><br>不允许旋转信封。</p><p><strong>示例:</strong></p><pre><code>输入: envelopes = [[5,4],[6,4],[6,7],[2,3]]输出: 3 解释: 最多信封的个数为 3, 组合为: [2,3] =&gt; [5,4] =&gt; [6,7]。</code></pre><h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p>先对二维数组中的首位进行升序排序，如果相等考虑第二位大小，同样是升序排序。之后对第二位使用第一题同样的方法即可以计算出最长上升序列</p><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><pre><code>class Solution &#123;    public int maxEnvelopes(int[][] envelopes) &#123;        if(envelopes.length&lt;1)&#123;return 0;&#125;        int m = envelopes.length, n = envelopes[0].length;        Arrays.sort(envelopes, new Comparator&lt;int[]&gt;()&#123;// 就是对二维数组首位排序，如果相等就看第二位            @Override            public int compare(int []x, int []y)&#123;                if(x[0]==y[0])return x[1]-y[1];                return x[0]-y[0];            &#125;        &#125;);        int []dp = new int[m];        for(int i=0;i&lt;m;i++)&#123;            dp[i] = 1;        &#125;        for(int i=1;i&lt;m;i++)&#123;            for(int j=0;j&lt;i;j++)&#123;                if(envelopes[i][1]&gt;envelopes[j][1]&amp;&amp;envelopes[i][0]&gt;envelopes[j][0])&#123;                    dp[i] = Math.max(dp[i], dp[j]+1);                &#125;            &#125;        &#125;        return Arrays.stream(dp).max().getAsInt();// 得到dp数组的最大值    &#125;&#125;</code></pre><p><img src="/img/leetcode/result2.png" alt="result2"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>两题都是动态规划内容中最为经典的单串题型，很适合入门动态规划。另外，两题都可以用二分法更新 <code>j</code> 的位置，可以很大的提升时间效率，在二分法专题将会有更详细的解法。</p>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
      <category>动态规划</category>
      
      <category>单串问题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java类与继承</title>
    <link href="/2021/02/24/Java%E7%B1%BB%E4%B8%8E%E7%BB%A7%E6%89%BF/"/>
    <url>/2021/02/24/Java%E7%B1%BB%E4%B8%8E%E7%BB%A7%E6%89%BF/</url>
    
    <content type="html"><![CDATA[<h2 id="类与继承"><a href="#类与继承" class="headerlink" title="类与继承"></a>类与继承</h2><span id="more"></span><h3 id="1-定义类"><a href="#1-定义类" class="headerlink" title="1. 定义类"></a><strong>1. 定义类</strong></h3><hr><p>类(class)是构造对象的模板与蓝图，由类构造(construct)对象的过程称之为实例(instance) 。标准JAVA库中提供了几千个类可用于各种目的。</p><p>封装(encapsulation)从形式上看，封装就是把数据和行为组合在一个包里，并对对象的使用者隐藏具体的实现方式。对象中的数据称之为实例字段(instance field)，操作数据的过程称为方法(method)。作为一个类的实例，特定对象都有一组特定的实例字段值。这些值的集合就是这个对象的当前状态，再类上调用任何方法都可能改变的个状态。</p><p><strong>· 举例:</strong></p><pre><code>public class Employee &#123;    // instance field    private String name;    private double salary;    private LocalDate hireDay;        // constructor    public Employee(String n, double s, int year, int month, int day)    &#123;        name = n;        salary = s;        hireDay = LocalDate.of(year, month, day);    &#125;        // a method    public String getName()&#123;        return name;    &#125;    ...&#125;</code></pre><h3 id="2-继承类"><a href="#2-继承类" class="headerlink" title="2. 继承类"></a><strong>2. 继承类</strong></h3><hr><h4 id="2-1-定义子类"><a href="#2-1-定义子类" class="headerlink" title="2.1 定义子类"></a>2.1 定义子类</h4><p>假设Manager和Employee的关系，继承Employee类来定义Manager，使用关键字extends来辨表示继承。</p><pre><code>public class Manager extends Employee&#123;    add methods and fields&#125;</code></pre><p>关键字extends表明正在构造的新类派生于一个已存在的类。这个已存在的类称为超类(superclass)，基类(base class)，父类(parent class); 新类称为子类(subclass)。一般称为超类与子类。</p><p>在Manager类中可以设立新的方法，Employee类的对象不可用。Employee类中的一切public方法在Manager中可用。</p><h4 id="2-2-覆盖方法"><a href="#2-2-覆盖方法" class="headerlink" title="2.2 覆盖方法"></a>2.2 覆盖方法</h4><p>以上的Employee类为例，salary是一个私有变量，所以在Manager类中不能直接调用，在不改变私有的情况下，如何使用salary变量?</p><p>可以使用Employee中的public方法getsalary()返回salary，当然Manager类同样继承了salary方法，在salary()中调用salary()会构成无限递归，此时可以使用: </p><pre><code>super.getSalary()</code></pre><p>这个语句调用的是超类中的方法。要使用这个变量可以用<code>double salary = super.getSalary();</code>来得到数值。</p><p>子类不能删除任何超类中的字段。</p><h4 id="2-3-子类构造器"><a href="#2-3-子类构造器" class="headerlink" title="2.3 子类构造器"></a>2.3 子类构造器</h4><pre><code>Public Manager(String name, double salary, int year, int month, int day)&#123;    super(name, salary, year, month, day);    bonus = 0;//Manager类比子类多了bones字段&#125;</code></pre><p><code>super(name, salary, year, month, day);</code>是调用超类的构造器。</p><p>如果子类的构造器没有显示的调用超类的构造器，讲自动地调用超类的无参构造器。如果超类没有无参构造器，Java便会报告一个错误。</p><p>如果声明一个Employee对象 e， e既可以引用Employee类型的变量，也可以引用Manager类型的变量。虚拟机知道e的实际引用对象类型，可以正确的调用相应的方法。</p><p>一个对象可以指示多种实际类型的现象称为多态(polymorphism)。在运行时候能够动态的选择适用的方法，称为动态绑定(dynamic binding)。</p><h4 id="2-4-继承层次"><a href="#2-4-继承层次" class="headerlink" title="2.4 继承层次"></a>2.4 继承层次</h4><p>继承不仅限于一个层次。例如Manager类同样可以派生出新的类。由一个公共超类派生出的所有类的集合称为继承层次(inheritance hierarchy)。在继承层次中，从某个特定的类到其祖先的路径称为该类的继承链(inheritance chain)。</p><p><img src="/img/Java/chain.png" alt="inheritance chain"></p><h4 id="2-5-多态"><a href="#2-5-多态" class="headerlink" title="2.5 多态"></a>2.5 多态</h4><p>继承的规则为“is-a”关系，例如每个经理都是员工，但每个员工并不是经理，所以讲Manager类设计为Employee的子类是有道理的。</p><p>“is-a”规则的另一种表述是替换原则(substitution principle)。他指出程序中出现超类对象任何地方都可以使用子类对象替换。</p><p><strong>例如:</strong></p><pre><code>Employee e;e = new Employee(...); //Employee object expectede = new Manager(...); //OK, Manager can be used as well</code></pre><p>正如上述的代码，Java中，对象变量是多态的(polymorphic)，一个超类可以引用其任何一个子类。</p><pre><code>Manager boss = new Manager(...);Employee[] staff = new Employee[3];staff[0] = boss;</code></pre><p>是完全正确的。</p><p>但是超类的引用不能赋给子类变量</p><pre><code>Manager m = staff[i]; //ERROR</code></pre><h4 id="2-6-理解方法调用"><a href="#2-6-理解方法调用" class="headerlink" title="2.6 理解方法调用"></a>2.6 理解方法调用</h4><p>准确地理解如何在对象上应用方法调用很重要。下面假设要调用x.f(args)，隐式参数x声明为类C的一个对象。下面是调用过程的详细描述：</p><ol><li><p>编译器查看对象地声明类型和方法名。注意可能存在多个方法名为f但是参数类型不一样的方法。例如f(int)/f(String)。编译器会一一列举C类中所有名为f的方法和其超类中所有名为f而且可访问的方法。(除private方法)</p></li><li><p>接下来，编译器要确定方法中调用的参数类型。如果在所有名为f的方法中存在一个与提供参数类型完全匹配的方法，就选用这个方法。这个过程称为重载解析(overloading resolution)。如果编译器没有找到参数类型匹配的方法，或者类型转换后有多个方法匹配，编译器会报告一个错误。</p><p> <strong>PS:</strong></p><pre><code class="方法的名字和参数列表称为方法的签名。">例如，f(int)和f(String)是两个有相同名字不同签名的方法。如果子类中定义了一个和超类签名相同的方法，那么子类中这个方法就会覆盖掉超类中这个相同签名的方法。</code></pre></li><li><p>如果是private方法、 static方法、 final方法或者构造器，那么编译器将可以准确地知道应该调用哪个方法。这称为静态绑定(static binding)。相对应的，如果调用的方法依赖于隐式参数的实际类型，就必须运行时使用动态绑定。</p></li><li><p>程序运行并且采用动态绑定调用方法时，虚拟机必须调用与x所引用对象的实际类型对于的那个方法。假设x的实际类型是D，它是C类的子类。如果D类定义了方法f(String)，就会调用这个方法；否则，将在D类的超类中寻找f(String)，以此类推。</p></li></ol><p>每次调用方法都要完成这个搜索，事件开销相当大。因此虚拟机预先为每个类计算了一个方法表(method table)，其中列出所有方法的签名和要调用的实际方法。这样一来在真正调用的时候，虚拟机查这个表就可以了。</p><h4 id="2-7-阻止继承-final类和方法"><a href="#2-7-阻止继承-final类和方法" class="headerlink" title="2.7 阻止继承: final类和方法"></a>2.7 阻止继承: final类和方法</h4><p>不允许扩展的类被称为final类。在定义类的时候使用了final修饰符就表明了这个类是final类。</p><p>声明格式如下: </p><pre><code>public final class Manager extends Employee&#123;    ...&#125;</code></pre><p>类中的某个特定方法也可以被声明为final。如果这样做，子类就不能覆盖这个方法。</p><p>例如: </p><pre><code>public class Employee&#123;    ...    public final String getName()    &#123;        return name;    &#125;    ...&#125;</code></pre><p>字段同样可以声明final。对于字段来说赋值final之后就不允许在改变值。同样，将方法和类声明final原因是确保它们不会再子类中被改变语义。String是常见的final类。</p><h4 id="2-8-强制类型转换"><a href="#2-8-强制类型转换" class="headerlink" title="2.8 强制类型转换"></a>2.8 强制类型转换</h4><p>将一个类型强制转换成另一种类型在Java中提供了一种特殊表示方法:</p><pre><code>double x = 3.405;int nx = (int) x;</code></pre><p>将表达式x的值舍去了小数部分。</p><p>有时候需要将某个类的对象引用转换成另一个类的对象引用。要完成对象引用的强制类型转换: </p><pre><code>staff[0] = boss;Manager boss = (Manager) staff[0];</code></pre><p>进行强制类型转换的唯一原因是：要在暂时忽视对象地实际类型之后使用对象的全部功能。例如，staff数组必须是Employee对象的数组，但我们需要将经理的元素复原成Manager对象，以便能访问新增加的所有变量。</p><p>如果一个子类的引用付给一个超类变量，是允许的。但超类的引用赋予一个子类变量，如果没有提前处理，将产生一个ClassCastException异常。因此，在进行强制转换之前，先查看是否能成功地转换。为此需要使用instanceof操作符</p><pre><code>if(staff[1] instanceof Manager)&#123;    boss = (Manager) staff[1];    ...&#125;</code></pre><p>综上所述，只能在继承层次内进行强制转换，且在超类强制转换成子类之前，应该使用instanaceof进行检查。</p><p><strong>一般情况下，尽量少用强制类型转换与instanceof运算符</strong></p><h4 id="2-9-抽象类"><a href="#2-9-抽象类" class="headerlink" title="2.9 抽象类"></a>2.9 抽象类</h4><p>在继承结构中，位于上层的类更具有一般性，即抽象性。比如，员工是一个人，学生也是一个人，人在他们的更上层。</p><p>为什么要提供一个高层次的抽象呢？每个人都有一些属性，如姓名。学生与员工都有姓名属性，因此通过引入一个公共的超类，我们就可以吧getName方法放在继承层次结构中的更高一层。</p><p>如果一个方法在员工和学生身上是截然不同的，例如调用工作方法，员工是上班而学生是上课。这时候就可以使用abstract关键字，这样就完全不用实现这个方法了。</p><pre><code>public abstract String getJob();//no implement required</code></pre><p>为了提高程序的清晰度，包含一个或多个抽象方法的类本身必须被声明为对象的。</p><pre><code>public abstract class Person&#123;    public abstract String gerJob();&#125;</code></pre><p>除了抽象方法，抽象类还可以包含字段和具体方法。</p><pre><code>public abstract class Person&#123;    private String name;    public Person(String name)    &#123;        this.name = name;    &#125;    public abstract String getJob();    public String getName()    &#123;        return name;    &#125;&#125;</code></pre><p>抽象方法在子类中具体实现。扩展抽象类可以有两种选择。一种是在子类中保留抽象类中的部分或所有抽象方法仍未定义，这样就必须将子类也标记未抽象类；另一种做法就是定义全部方法，这样一来，子类就不是抽象的了。</p><p>即使不含有抽象方法，也可以将类声明为抽象类。</p><p>抽象类不能实例化。也就是说，如果讲一个类声明为abstract，就不能创建这个类的对象。例如: </p><pre><code>new Person(&quot;Name&quot;);</code></pre><p>需要注意，可以定义一个抽象类的对象变量，但是这样一个变量只能引用非抽象子类的对象。例如:</p><pre><code>Person p = nwe Student(&quot;name&quot;, &quot;...&quot;);</code></pre><p>这里p是一个抽象类型的Person变量，它引用了一个非抽象子类Student的实例。</p><h4 id="2-10-受保护访问"><a href="#2-10-受保护访问" class="headerlink" title="2.10 受保护访问"></a>2.10 受保护访问</h4><p>大部分情况，我们将类中的字段标记为private，而方法标记为public。任何声明为private的内容对其他类都是不可见得。</p><p>不过有些时候，你可能希望限制超类中的某个方法只允许子类访问，更少见的，可能希望允许子类的方法访问超类的某些字段。为此，需要将这些方法声明为保护(pretected)。</p><p>在Java中，保护字段只能由同一个包中的类访问。</p><p><strong>小结</strong><br><strong>1. 仅本类可见——private。</strong><br><strong>2. 对外部完全可见——public</strong><br><strong>3. 对本包合所有子类可见——protected</strong><br><strong>4. 对本包可见——默认，不需要修饰符</strong></p><h4 id="2-11-参考文献"><a href="#2-11-参考文献" class="headerlink" title="2.11 参考文献"></a>2.11 参考文献</h4><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>Java核心技术 卷一(第11版) P155<a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span>Java编程思想(第4版) P125<a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
      <category>Java</category>
      
      <category>Java基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编程语言的运用</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>如何上线一个制作完成的网页项目</title>
    <link href="/2021/02/24/%E5%A6%82%E4%BD%95%E4%B8%8A%E7%BA%BF%E4%B8%80%E4%B8%AA%E5%88%B6%E4%BD%9C%E5%AE%8C%E6%88%90%E7%9A%84%E7%BD%91%E9%A1%B5%E9%A1%B9%E7%9B%AE/"/>
    <url>/2021/02/24/%E5%A6%82%E4%BD%95%E4%B8%8A%E7%BA%BF%E4%B8%80%E4%B8%AA%E5%88%B6%E4%BD%9C%E5%AE%8C%E6%88%90%E7%9A%84%E7%BD%91%E9%A1%B5%E9%A1%B9%E7%9B%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="如何上线一个制作完成的网页项目"><a href="#如何上线一个制作完成的网页项目" class="headerlink" title="如何上线一个制作完成的网页项目"></a>如何上线一个制作完成的网页项目</h1><p><font size=3 color=red >以下操作以腾讯云为例</font></p><span id="more"></span><h2 id="1-租用域名"><a href="#1-租用域名" class="headerlink" title="1. 租用域名"></a><strong>1. 租用域名</strong></h2><p><img src="/img/HTML/DNSPod.png" alt="购买域名"></p><p>搜索自己喜欢的域名</p><p><strong>例:</strong></p><p><code>www.example.com</code>需要搜索example</p><p><img src="/img/HTML/example.png" alt="result"></p><p>顶级域名不一定需要<code>com</code>，但不建议使用中文</p><p>PS: 域名购买越长期越优惠</p><h2 id="2-租用一台够用的服务器"><a href="#2-租用一台够用的服务器" class="headerlink" title="2. 租用一台够用的服务器"></a><strong>2. 租用一台够用的服务器</strong></h2><ul><li><p>如何选择服务器?</p><p>  个人小网站访问量较少(一天不到1000)，最低配置已经能满足需求。</p><p>  流量，数据量，访问量大的按照实际情况购买。</p><p>  所在地点尽量购买空间距离近的服务器，但是在国内访问速度差距不大。</p><p>  PS: 建议购买有独立公网IP的服务器，<strong>学生认证非常非常优惠!!</strong></p></li><li><p>如何租用服务器?</p><p>  <strong><em>学生优惠：</em></strong><br>  <img src="/img/HTML/server.png" alt="学生优惠"><br>  <a href="https://curl.qcloud.com/1xhvBLa7">活动地址</a></p><p>  <strong><em>普通租用：</em></strong><br>  <img src="/img/HTML/serverbuy.png" alt="购买服务器"><br>  <a href="https://curl.qcloud.com/UiELXXHV">购买地址</a></p><p>  操作系统建议选常规服务器操作系统CentOS，三种都是命令行操作</p><p>  PS: 新用户同样有优惠，但必须第一次购买的就是服务器，后续续费服务器没有优惠</p><p>  购买之后在进入云服务器实例中即可以看到(区域一定要选自己购买的区域才能看到)<br>  <img src="/img/HTML/instance.png" alt="实例"></p></li></ul><h2 id="3-域名备案"><a href="#3-域名备案" class="headerlink" title="3. 域名备案"></a><strong>3. 域名备案</strong></h2><p><a href="https://cloud.tencent.com/product/ba">腾讯云备案地址</a></p><p><img src="/img/HTML/record.png" alt="备案流程"></p><p>按照租用服务器的网站要求进行备案，国内域名服务器只有备案完成的域名才能正常DNS解析。</p><p>期间保持电话畅通。</p><p>PS:<br>    · <strong>一切问题工作人员都会联系你帮你解决，不需要担心。</strong><br>    · 网站标题不会在任何地方展示，仅作为备案。<br>    · 个人网站网站服务内容选其他，备注部分正常填写即可。<br>    · 按照要求验证提交，之后坐等就可以了，期间把网站写好，备案完成即可上线。<br>    · 备案完成后会受到公安备案信息，建议按照信息要求进行公安备案。</p><h2 id="4-腾讯云静态网站托管上线网站"><a href="#4-腾讯云静态网站托管上线网站" class="headerlink" title="4. 腾讯云静态网站托管上线网站"></a><strong>4. 腾讯云静态网站托管上线网站</strong></h2><p><a href="https://cloud.tencent.com/product/wh">静态网站托管</a></p><p>如果访问量不大，基本为免费使用</p><p><img src="/img/HTML/static1.png" alt="第一步"></p><p><img src="/img/HTML/static2.png" alt="第二步">(免费一定要勾起)</p><p><img src="/img/HTML/static3.png" alt="第三步"></p><p><strong>HTML网页主页名称一定要用index.html</strong></p><p>其他文件放在src、img等中以文件夹形式上传</p><p><img src="/img/HTML/upload.png" alt="upload">  </p><p>随后云产品中选择DNS解析进入</p><p><img src="/img/HTML/DNS.png" alt="DNSPOD"></p><ul><li><p>DNS解析</p><ul><li>添加解析</li><li>添加记录</li><li>主机记录为域名前的字符串，例如www，如果想通过域名直接访问，则填@</li><li>记录类型选A, 记录值填服务器的IP地址。</li></ul></li></ul><p>回到静态网站托管界面，进入详细配置，选择添加域名(全称)</p><p>SSL证书处点击申请SSL证书</p><p><img src="/img/HTML/SSL.png" alt="SSL证书"></p><p>申请免费SSL证书，一路推荐设置即可</p><p>获得SSL证书后，回到创建自定义域名刷新后出现SSL证书，进入部署。</p><p>复制CNAME地下的地址，到DNS解析中修改添加的记录为CNAME，记录值为复制的地址。</p><p><font size=4>此刻终于可以通过域名访问自己本地写好的网页，上线成功！！</font></p><h2 id="5-参考视频"><a href="#5-参考视频" class="headerlink" title="5. 参考视频"></a><strong>5. 参考视频</strong></h2><p><a href="https://www.bilibili.com/video/BV18a4y1Y7e9">BV18a4y1Y7e9</a> </p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
      <category>网页</category>
      
    </categories>
    
    
    <tags>
      
      <tag>域名</tag>
      
      <tag>服务器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hexo博客的创建与使用</title>
    <link href="/2021/02/23/hexo%E5%8D%9A%E5%AE%A2%E7%9A%84%E5%88%9B%E5%BB%BA%E4%B8%8E%E4%BD%BF%E7%94%A8/"/>
    <url>/2021/02/23/hexo%E5%8D%9A%E5%AE%A2%E7%9A%84%E5%88%9B%E5%BB%BA%E4%B8%8E%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="hexo博客的创建与使用"><a href="#hexo博客的创建与使用" class="headerlink" title="hexo博客的创建与使用"></a>hexo博客的创建与使用</h1><span id="more"></span><h2 id="1-安装node-js"><a href="#1-安装node-js" class="headerlink" title="1.安装node.js"></a><strong>1.安装node.js</strong></h2><p><a href="https://nodejs.org/en/">下载地址</a></p><p><strong>LTS</strong>为长期支持版</p><p>命令行中键入<code>node -v</code>与<code>npm -v</code>查看是否安装完成，以及是否存在与环境变量。</p><p>npm是一种包管理器</p><h2 id="2-安装cnpm"><a href="#2-安装cnpm" class="headerlink" title="2. 安装cnpm"></a><strong>2. 安装cnpm</strong></h2><p>cnpm是淘宝的国内镜像源，为了安装hexo更加快速</p><pre><code>npm install -g cnpm --registry=https://registry.npm.taobao.org</code></pre><p>命令行中键入<code>cnpm -v</code>查看是否安装完成，以及是否存在与环境变量。</p><h2 id="3-安装hexo框架"><a href="#3-安装hexo框架" class="headerlink" title="3. 安装hexo框架"></a><strong>3. 安装hexo框架</strong></h2><pre><code>cnpm install -g hexo-cli</code></pre><p>命令行中键入<code>hexo -v</code>查看是否安装完成，以及是否存在与环境变量。</p><h2 id="4-在blog文件夹中创建博客"><a href="#4-在blog文件夹中创建博客" class="headerlink" title="4. 在blog文件夹中创建博客"></a><strong>4. 在blog文件夹中创建博客</strong></h2><p>所有操作都在blog中，实在解决不了错误，就直接删掉</p><p><font size=4 color=red><strong>以下一切操作在blog文件夹中的命令行执行</strong></font></p><p><strong>初始化hexo</strong></p><pre><code>hexo init</code></pre><p><strong>启动hexo</strong></p><pre><code>hexo s</code></pre><p>即可以在localhost:4000本地访问博客</p><p><strong>新建blog</strong></p><pre><code>hexo new TitleName</code></pre><p>TitleName 为文章名   </p><p>bolg用md编辑器编写, UNIX也可以直接insert形式编写</p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
      <category>hexo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>个人主页</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Markdown进阶语法</title>
    <link href="/2021/02/23/Markdown%E8%BF%9B%E9%98%B6%E8%AF%AD%E6%B3%95/"/>
    <url>/2021/02/23/Markdown%E8%BF%9B%E9%98%B6%E8%AF%AD%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="Markdown进阶语法"><a href="#Markdown进阶语法" class="headerlink" title="Markdown进阶语法"></a>Markdown进阶语法</h1><span id="more"></span><p>引入HTML的标签语法来实现更进阶的语法</p><h2 id="1-更改字体、大小、颜色"><a href="#1-更改字体、大小、颜色" class="headerlink" title="1. 更改字体、大小、颜色"></a><strong>1. 更改字体、大小、颜色</strong></h2><p><strong>语法:</strong></p><pre><code>&lt;font face=&quot;黑体&quot;&gt;我是黑体字&lt;/font&gt;&lt;font face=&quot;微软雅黑&quot;&gt;我是微软雅黑&lt;/font&gt;&lt;font face=&quot;STCAIYUN&quot;&gt;我是华文彩云&lt;/font&gt;&lt;font color=red&gt;我是红色&lt;/font&gt;&lt;font color=#008000&gt;我是绿色&lt;/font&gt;&lt;font color=Blue&gt;我是蓝色&lt;/font&gt;&lt;font size=5&gt;我是尺寸&lt;/font&gt;&lt;font face=&quot;黑体&quot; color=green size=5&gt;我是黑体，绿色，尺寸为5&lt;/font&gt;</code></pre><p><strong>效果如下:</strong></p><p><font face="黑体">我是黑体字</font></p><p><font face="微软雅黑">我是微软雅黑</font></p><p><font face="STCAIYUN">我是华文彩云</font></p><p><font color=red>我是红色</font></p><p><font color=#008000>我是绿色</font></p><p><font color=Blue>我是蓝色</font></p><p><font size=5>我是尺寸</font></p><p><font face="黑体" color=green size=5>我是黑体，绿色，尺寸为5</font></p><h2 id="2-为文字添加背景色"><a href="#2-为文字添加背景色" class="headerlink" title="2. 为文字添加背景色"></a><strong>2. 为文字添加背景色</strong></h2><p>借助 table, tr, td 等表格标签的 bgcolor 属性来实现背景色。只是将那一整行看作一个表格，更改了那个格子的背景色（bgcolor）。</p><p><strong>语法:</strong></p><p><code>&lt;table&gt;&lt;tr&gt;&lt;td bgcolor=yellow&gt;背景色yellow&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;</code></p><p><strong>效果如下:</strong></p><table><tr><td bgcolor=yellow>背景色yellow</td></tr></table><h2 id="3-设置文字居中"><a href="#3-设置文字居中" class="headerlink" title="3. 设置文字居中"></a><strong>3. 设置文字居中</strong></h2><p>用p标签或者center</p><p><strong>语法:</strong></p><pre><code>&lt;center&gt;居中&lt;/center&gt;&lt;p align=&quot;left&quot;&gt;左对齐&lt;/p&gt;&lt;p align=&quot;right&quot;&gt;右对齐&lt;/p&gt;</code></pre><p><strong>效果如下:</strong></p><center>居中</center><p align="left">左对齐</p><p align="right">右对齐</p><h2 id="4-加入上下标"><a href="#4-加入上下标" class="headerlink" title="4. 加入上下标"></a><strong>4. 加入上下标</strong></h2><p>仍是HTML上下标语法</p><p><strong>语法:</strong></p><pre><code>H&lt;sub&gt;2&lt;/sub&gt;O  CO&lt;sub&gt;2&lt;/sub&gt;爆米&lt;sup&gt;TM&lt;/sup&gt;</code></pre><p><strong>效果如下:</strong></p><p>H<sub>2</sub>O  CO<sub>2</sub><br>爆米<sup>TM</sup></p><h2 id="5-超链接"><a href="#5-超链接" class="headerlink" title="5. 超链接"></a><strong>5. 超链接</strong></h2><p>Markdown 支持两种形式的链接语法： 行内式和参考式两种形式。</p><p>不管是哪一种，链接文字都是用 [方括号] 来标记。</p><p>要建立一个行内式的链接，只要在方块括号后面紧接着圆括号并插入网址链接即可，注意方括号和圆括号之间一定不能有空格，如果你还想要加上链接的 title 文字，只要在网址后面，用双引号把 title 文字包起来即可。</p><p><strong>语法:</strong></p><pre><code>This is [an example](http://example.com/ &quot;Title&quot;) inline link.[This link](http://example.net/) has no title attribute.</code></pre><p><strong>效果如下:</strong></p><p>This is <a href="http://example.com/" title="Title">an example</a> inline link.</p><p><a href="http://example.net/">This link</a> has no title attribute.</p><p><strong>注：</strong>如果想要在新页面中打开的话可以用html语言的a标签代替。<br>    <a href="超链接地址" target="_blank">超链接名</a></p><p>参考式的链接是在链接文字的括号后面再接上另一个方括号，而在第二个方括号里面要填入用以辨识链接的标记：</p><pre><code>This is [an example][id] reference-style link.</code></pre><p>接着，在文件的任意处，你可以把这个标记的链接内容定义出来:</p><pre><code>[id]: http://example.com/  &quot;Optional Title Here&quot;</code></pre><p>链接内容的形式为： 方括号（前面可以选择性地加上至多三个空格来缩进），里面输入链接文字 接着一个冒号 接着一个以上的空格或制表符 接着链接的网址 选择性地接着 title 内容，可以用单引号、双引号或是括弧包着 链接网址也可以用尖括号包起来：<br><code>[id]: &lt;http://example.com/&gt; &quot;Optional Title Here&quot;</code></p><p>链接辨别标签可以有字母、数字、空白和标点符号，但是并不区分大小写。</p><p>链接的定义可以放在文件中的任何一个地方，我比较偏好直接放在链接出现段落的后面，你也可以把它放在文件最后面，就像是注解一样。</p><p>此外，用这个方法还可以将图片转化为base64编码保存在.md文件中，这将在插入图片中介绍。</p><p><strong>下面是一个参考式链接的范例：</strong></p><pre><code>I get 10 times more traffic from [Google] [1] than from[Yahoo] [2] or [MSN] [3].  [1]: http://google.com/        &quot;Google&quot;  [2]: http://search.yahoo.com/  &quot;Yahoo Search&quot;  [3]: http://search.msn.com/    &quot;MSN Search&quot;</code></pre><p>还可以直接用链接名称的方式写：</p><pre><code>I get 10 times more traffic from [Google][] than from[Yahoo][] or [MSN][].  [google]: http://google.com/        &quot;Google&quot;  [yahoo]:  http://search.yahoo.com/  &quot;Yahoo Search&quot;  [msn]:    http://search.msn.com/    &quot;MSN Search&quot;</code></pre><h2 id="6-自动链接"><a href="#6-自动链接" class="headerlink" title="6. 自动链接"></a><strong>6. 自动链接</strong></h2><p>除了上面的超链接方式，Markdown 还支持以比较简短的自动链接形式来处理网址和电子邮件信箱，只要是用尖括号包起来， Markdown 就会自动把它转成链接。</p><p><strong>语法:</strong></p><pre><code>&lt;http://example.com/&gt;</code></pre><p><strong>效果如下:</strong></p><p><a href="http://example.com/">http://example.com/</a></p><h2 id="8-插入图片"><a href="#8-插入图片" class="headerlink" title="8. 插入图片"></a><strong>8. 插入图片</strong></h2><p><strong><em>这里只说明加入hexo blog较为简单的插入图片方法</em></strong></p><p>使用插件<code>hexo-renderer-marked</code>解决，用<code>npm install hexo-renderer-marked</code>命令直接安装，之后在_config.yaml更改配置:</p><pre><code>post_asset_folder: falsemarked:  prependRoot: true  postAsset: true</code></pre><p>之后就能以该hexo的theme文件夹中source为相对路径的起始点，调用目录中的文件的文件，不影响上传</p><h2 id="9-LaTeX公式"><a href="#9-LaTeX公式" class="headerlink" title="9. LaTeX公式"></a><strong>9. LaTeX公式</strong></h2><p>Markdown还有一大优势就是可以支持 LaTeX 的公式。 $ 表示行内公式 $$ 表示整行公式 访问<a href="https://zhuanlan.zhihu.com/p/110756681">MathJax</a>参考更多使用方法。</p><h2 id="10-参考链接"><a href="#10-参考链接" class="headerlink" title="10. 参考链接"></a><strong>10. 参考链接</strong></h2><p><a href="https://zhuanlan.zhihu.com/p/99319314">Markdown语法及原理从入门到高级</a></p>]]></content>
    
    
    <categories>
      
      <category>Markdown</category>
      
    </categories>
    
    
    <tags>
      
      <tag>文本工具</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode1052.爱生气的书店老板</title>
    <link href="/2021/02/23/leetcode1052-%E7%88%B1%E7%94%9F%E6%B0%94%E7%9A%84%E4%B9%A6%E5%BA%97%E8%80%81%E6%9D%BF/"/>
    <url>/2021/02/23/leetcode1052-%E7%88%B1%E7%94%9F%E6%B0%94%E7%9A%84%E4%B9%A6%E5%BA%97%E8%80%81%E6%9D%BF/</url>
    
    <content type="html"><![CDATA[<h1 id="爱生气的书店老板"><a href="#爱生气的书店老板" class="headerlink" title="爱生气的书店老板"></a>爱生气的书店老板</h1><p>今天，书店老板有一家店打算试营业<code>customers.length</code> 分钟。每分钟都有一些顾客<code>（customers[i]）</code>会进入书店，所有这些顾客都会在那一分钟结束后离开。</p><span id="more"></span><p>在某些时候，书店老板会生气。 如果书店老板在第 i 分钟生气，那么 <code>grumpy[i] = 1</code>，否则 <code>grumpy[i] = 0</code>。 当书店老板生气时，那一分钟的顾客就会不满意，不生气则他们是满意的。</p><p>书店老板知道一个秘密技巧，能抑制自己的情绪，可以让自己连续 X 分钟不生气，但却只能使用一次。</p><p>请你返回这一天营业下来，最多有多少客户能够感到满意的数量。</p><ul><li><strong>我的思路</strong></li></ul><hr><p>先计算出在不存在控制生气时间的情况下客人的人数，再维护一个固定长度为X的滑窗来获得最大滑窗中能通过控制脾气能留住的人</p><ul><li><strong>我的代码:</strong></li></ul><hr><pre><code>class Solution &#123;    public int maxSatisfied(int[] customers, int[] grumpy, int X) &#123;        int len = customers.length;        int res = 0;        for(int i=0;i&lt;len;i++)&#123;            if(grumpy[i]==0)&#123;                res += customers[i];            &#125;        &#125;        int left = 0, right = 0;        int temp = 0, m_temp = 0;        while(right&lt;X)&#123;            if(grumpy[right]!=0)&#123;                temp+=customers[right];            &#125;            right++;        &#125;        right--;        while(right&lt;len)&#123;            m_temp = Math.max(m_temp, temp);            if(grumpy[left]!=0)&#123;temp -= customers[left];&#125;            left++;            right++;            if(right&lt;len&amp;&amp;grumpy[right]!=0)&#123;temp += customers[right];&#125;        &#125;        return res+m_temp;            &#125;&#125;</code></pre><p><img src="/img/leetcode/1052.png" alt="result"></p>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
      <category>滑动窗口</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>随笔1</title>
    <link href="/2021/02/22/%E9%9A%8F%E7%AC%941/"/>
    <url>/2021/02/22/%E9%9A%8F%E7%AC%941/</url>
    
    <content type="html"><![CDATA[<h1 id="HELLO-WORLD"><a href="#HELLO-WORLD" class="headerlink" title="HELLO WORLD!!"></a>HELLO WORLD!!</h1><span id="more"></span><p>自娱自乐</p>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Markdown入门语法</title>
    <link href="/2021/02/22/Markdown%E5%85%A5%E9%97%A8%E8%AF%AD%E6%B3%95/"/>
    <url>/2021/02/22/Markdown%E5%85%A5%E9%97%A8%E8%AF%AD%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="Markdown入门语法"><a href="#Markdown入门语法" class="headerlink" title="Markdown入门语法"></a>Markdown入门语法</h1><span id="more"></span><h2 id="1-标题"><a href="#1-标题" class="headerlink" title="1. 标题"></a><strong>1. 标题</strong></h2><pre><code>This is an H1===This is an H2---</code></pre><!-- more --><h2 id="2-字体"><a href="#2-字体" class="headerlink" title="2. 字体"></a><strong>2. 字体</strong></h2><pre><code>**这是加粗**__这也是加粗__*这是倾斜*_这也是倾斜_***这是加粗倾斜***~~这是加删除线~~</code></pre><h2 id="3-分割线"><a href="#3-分割线" class="headerlink" title="3. 分割线"></a><strong>3. 分割线</strong></h2><pre><code>* * **************- - -_________________</code></pre><p>效果如下：</p><hr><hr><hr><hr><hr><h2 id="4-引用"><a href="#4-引用" class="headerlink" title="4. 引用"></a><strong>4. 引用</strong></h2><p>在引用的文字前加 &gt; 即可。 在 Markdown 文件中建立一个区块引用，那会看起来像是你自己先断好行，然后在每行的最前面加上 &gt; ：</p><pre><code>&gt; This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,&gt; consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.&gt; Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.&gt; &gt; Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse&gt; id sem consectetuer libero luctus adipiscing.</code></pre><p>效果如下：</p><blockquote><p>This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,<br>consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.<br>Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.</p><p>Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse<br>id sem consectetuer libero luctus adipiscing.</p></blockquote><p>Markdown 也允许你偷懒只在整个段落的第一行最前面加上 &gt; ：</p><h2 id="5-列表"><a href="#5-列表" class="headerlink" title="5. 列表"></a><strong>5. 列表</strong></h2><p>有序列表则使用数字接着一个英文句点作为标记。 示例：</p><pre><code>1. 列表内容2. 列表内容3. 列表内容注意：序号跟内容之间要有空格</code></pre><p>很重要的一点是，你在列表标记上使用的数字并不会影响输出的 HTML 结果。</p><p>只按第一个数字来排序，因此第一个最好是1。</p><hr><pre><code>* 一级无序列表内容       * 二级无序列表内容       * 二级无序列表内容       * 二级无序列表内容</code></pre><p>效果如下：</p><ul><li><p>一级无序列表内容</p><ul><li>二级无序列表内容</li><li>二级无序列表内容</li><li>二级无序列表内容</li></ul></li></ul><h2 id="6-代码"><a href="#6-代码" class="headerlink" title="6. 代码"></a><strong>6. 代码</strong></h2><p>在Markdown中加入代码块有两种方式： 第一种，只要简单地缩进 4 个空格或是 1 个制表符就可以</p><p><strong>单行代码</strong>：代码之间分别用一个反引号包起来即可；</p><pre><code>这里有一句代码`代码内容`。</code></pre><p>效果如下：</p><p>这里有一句代码<code>代码内容</code>。</p><p><strong>代码块</strong>：代码之间分别用三个反引号包起来，且两边的反引号单独占一行</p><pre><code>\```      代码...      代码...      代码...\```\ 是为了防止转译，实际是没有的。</code></pre><p>效果如下：</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs erlang">代码...<br>代码...<br>代码...<br></code></pre></td></tr></table></figure><h2 id="7-段落与换行"><a href="#7-段落与换行" class="headerlink" title="7. 段落与换行"></a><strong>7. 段落与换行</strong></h2><p>一个 Markdown 段落是由一个或多个连续的文本行组成，它的前后要有一个以上的空行（空行的定义是显示上看起来像是空的，便会被视为空行。比方说，若某一行只包含空格和制表符，则该行也会被视为空行）。普通段落不该用空格或制表符来缩进。 <strong>我们在两个不同的文字块之间，一定要空行以示区分，不然就会被归入同一文字块中。</strong> Markdown 允许段落内的强迫换行（插入换行符）。 如果想要空一行，在插入处先按入两个以上的空格然后回车，即可。</p><p>但有时也可以使用标记来强制空行和空格，比如需要首行缩进的时候： 一个空格大小的表示：\  或 \  两个空格的大小表示：\ 或 \ 不换行空格：\ 或 \ 强制空行： \</p>]]></content>
    
    
    <categories>
      
      <category>Markdown</category>
      
    </categories>
    
    
    <tags>
      
      <tag>文本工具</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
